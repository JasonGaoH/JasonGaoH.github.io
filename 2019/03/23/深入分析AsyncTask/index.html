<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="坚持输出，坚持书写，才可以持续成长">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      深入分析AsyncTask | JasonGao Thoughts
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    <script src="/js/qrious.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    <script src="/js/local-search.js"></script>

<link rel="alternate" href="atom.xml" title="JasonGao Thoughts" type="application/atom+xml">
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>JasonGao Thoughts</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">Series</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">Series</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off" placeholder="Please enter your keyword(s) to search." spellcheck="false" type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>深入分析AsyncTask</h2>
  <p class="post-date">2019-03-23</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><ol>
<li>什么是AsyncTask</li>
</ol>
<hr>
<p>AsyncTask 即 asynchronous task，异步任务。</p>
<p>AsyncTask实际上是围绕Thread和Handler设计的一个辅助类，在内部是对Thread和Handler的一种封装。AsyncTask的异步体现在由后台线程进行运算（访问网络等比较耗时的操作），然后将结果发布到用户界面上来更新UI，使用AsyncTask使得我不用操作Thread和Handler。<br> <a id="more"></a></p>
<ol start="2">
<li>AsyncTask的简单使用</li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new AsyncTask&lt;String,String,String&gt;()&#123;</span><br><span class="line">    //// 运行在主线程中，做预备工作/////</span><br><span class="line">    onPreExecute()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    // 运行在子线程中，做耗时操作</span><br><span class="line">    String doingBackGround(String s)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    // 运行在主线程中，耗时操作完成，更新UI</span><br><span class="line">    onPostExecute(String s)&#123;</span><br><span class="line">    			</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;.execute(String);</span><br></pre></td></tr></table></figure>
<p>AsyncTask用法比较简单，Google设计这个类就是为了方便我们进行类似Handler这样的异步操作。</p>
<h5 id="如上代码，一般使用AsyncTask只要重写里面的三个方法，onPreExecute和onPostExecute不是抽象方法，不是必须实现，实现这两种方法一般能让代码的逻辑更加清晰。onPreExecute运行在主线程中，做一些准备工作。onPostExecute同样运行在主线程中，用于在耗时操作完成后，更新UI。另外，还有一个onProgressUpdate方法，用于在后台任务执行过程中来实时地更新UI。"><a href="#如上代码，一般使用AsyncTask只要重写里面的三个方法，onPreExecute和onPostExecute不是抽象方法，不是必须实现，实现这两种方法一般能让代码的逻辑更加清晰。onPreExecute运行在主线程中，做一些准备工作。onPostExecute同样运行在主线程中，用于在耗时操作完成后，更新UI。另外，还有一个onProgressUpdate方法，用于在后台任务执行过程中来实时地更新UI。" class="headerlink" title="如上代码，一般使用AsyncTask只要重写里面的三个方法，onPreExecute和onPostExecute不是抽象方法，不是必须实现，实现这两种方法一般能让代码的逻辑更加清晰。onPreExecute运行在主线程中，做一些准备工作。onPostExecute同样运行在主线程中，用于在耗时操作完成后，更新UI。另外，还有一个onProgressUpdate方法，用于在后台任务执行过程中来实时地更新UI。"></a>如上代码，一般使用AsyncTask只要重写里面的三个方法，onPreExecute和onPostExecute不是抽象方法，不是必须实现，实现这两种方法一般能让代码的逻辑更加清晰。onPreExecute运行在主线程中，做一些准备工作。onPostExecute同样运行在主线程中，用于在耗时操作完成后，更新UI。另外，还有一个onProgressUpdate方法，用于在后台任务执行过程中来实时地更新UI。</h5><h5 id="doingBackGround则是抽象方法，必须实现，我们使用AsyncTask时希望将一些耗时操作放在子线程中，doingBackGround中逻辑就相当于我们在Thread-Handler中Thread中的run方法中实现的逻辑。"><a href="#doingBackGround则是抽象方法，必须实现，我们使用AsyncTask时希望将一些耗时操作放在子线程中，doingBackGround中逻辑就相当于我们在Thread-Handler中Thread中的run方法中实现的逻辑。" class="headerlink" title="doingBackGround则是抽象方法，必须实现，我们使用AsyncTask时希望将一些耗时操作放在子线程中，doingBackGround中逻辑就相当于我们在Thread-Handler中Thread中的run方法中实现的逻辑。"></a>doingBackGround则是抽象方法，必须实现，我们使用AsyncTask时希望将一些耗时操作放在子线程中，doingBackGround中逻辑就相当于我们在Thread-Handler中Thread中的run方法中实现的逻辑。</h5><h5 id="execute方法用于启动执行任务"><a href="#execute方法用于启动执行任务" class="headerlink" title="execute方法用于启动执行任务"></a>execute方法用于启动执行任务</h5><ol start="3">
<li>从源码角度看AsyncTask的设计</li>
</ol>
<hr>
<p>接下来进入这篇文章的重点，我们从源码角度来分析AsyncTask是如何实现的。</p>
<blockquote>
<h4 id="AsyncTask的execute方法"><a href="#AsyncTask的execute方法" class="headerlink" title="AsyncTask的execute方法"></a>AsyncTask的execute方法</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">        return executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面是execute方法，发现execute其实内部调用的executeOnExecutor方法，调用executeOnExecutor方法传递了两个参数，这里第一个传递了一个默认的执行器，关于这个sDefaultExecutor我们再来讲，我们现在来看AsyncTask的流程设计。</p>
<p>我们来看这个executeOnExecutor方法,这里将不重要的代码略去了，其实这里面的逻辑比较清晰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</span><br><span class="line">           Params... params) &#123;</span><br><span class="line">       .....</span><br><span class="line">       .....</span><br><span class="line"></span><br><span class="line">       mStatus = Status.RUNNING;</span><br><span class="line">       ////////////////////////////////</span><br><span class="line">       // 第一步：在主线程中执行准备操作////</span><br><span class="line">       onPreExecute();</span><br><span class="line">       // 第二步：把params参数赋值给mWorker</span><br><span class="line">       mWorker.mParams = params;</span><br><span class="line">       // 第三步：用线程池执行mFuture</span><br><span class="line">       exec.execute(mFuture);</span><br><span class="line">       ///////////////////////</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>第一步，onPreExecute与上面的介绍一样，进行准备工作，这个就没有必要分析，如果我们没有重写，就不会做相关的准备。我们主要第二步和第三步，第二步，把params参数赋值给mWorker，params是execute中传递过来的参数，同时也是泛型中第一个参数，将params赋值给mWorker，那么mWorker是什么呢？</p>
<blockquote>
<h4 id="AsyncTask的构造方法"><a href="#AsyncTask的构造方法" class="headerlink" title="AsyncTask的构造方法"></a>AsyncTask的构造方法</h4><p>我们继续看源码:主意到mWorker是在AsyncTask的构造方法中创建的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public AsyncTask() &#123;</span><br><span class="line">        mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">            public Result call() throws Exception &#123;</span><br><span class="line">               .....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void done() &#123;</span><br><span class="line">               .....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先，mWorker在构造方法中创建，它是一个匿名内部类，那WorkerRunnable是个什么东西呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123;</span><br><span class="line">       Params[] mParams;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现WorkerRunnable其实就是一个Callable，同时在execute方法中mFuture也在这里创建了出来，这里会将mWorker传递到FutureTask中去，那么将mFuture传进去做了什么什么操作呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">       if (callable == null)</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       //////这里将mWorker传递进来，其实就是callable///</span><br><span class="line">       /////////////</span><br><span class="line">       this.callable = callable;</span><br><span class="line">       this.state = NEW;       // ensure visibility of callable</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>FutureTask是java.util.concurrent，FutureTask继承了Future，通过 Future 接口，可以尝试取消尚未完成的任务，查询任务已经完成还是取消了，以及提取（或等待）任务的结果值。</p>
<p>在AsyncTask的构造方法中，将mWorker传进来，即将callable传进来，因为mWorker就是callable。</p>
<p>这样在上面的executeOnExecutor中的第三步中，==exec.execute(mFuture)== 用线程池来执行mFuture，其实就是执行mFuture中的run方法，我们来看FutureTask中的run方法：</p>
<blockquote>
<h4 id="FutureTask中的run方法"><a href="#FutureTask中的run方法" class="headerlink" title="FutureTask中的run方法"></a>FutureTask中的run方法</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">       if (state != NEW ||</span><br><span class="line">           !UNSAFE.compareAndSwapObject(this, runnerOffset,</span><br><span class="line">                                        null, Thread.currentThread()))</span><br><span class="line">           return;</span><br><span class="line">       try &#123;</span><br><span class="line">           Callable&lt;V&gt; c = callable;</span><br><span class="line">           if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">               V result;</span><br><span class="line">               boolean ran;</span><br><span class="line">               try &#123;</span><br><span class="line">                  //① 调用callable中的call方法，其实就是mWorker中的call方法</span><br><span class="line">                  //并且将结果赋值给result</span><br><span class="line">                   result = c.call();</span><br><span class="line">                   ran = true;</span><br><span class="line">               &#125; catch (Throwable ex) &#123;</span><br><span class="line">                   result = null;</span><br><span class="line">                   ran = false;</span><br><span class="line">                   setException(ex);</span><br><span class="line">               &#125;</span><br><span class="line">               if (ran)</span><br><span class="line">                   //② 调用自己内部的set方法设置结果</span><br><span class="line">                   set(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           // runner must be non-null until state is settled to</span><br><span class="line">           // prevent concurrent calls to run()</span><br><span class="line">           runner = null;</span><br><span class="line">           // state must be re-read after nulling runner to prevent</span><br><span class="line">           // leaked interrupts</span><br><span class="line">           int s = state;</span><br><span class="line">           if (s &gt;= INTERRUPTING)</span><br><span class="line">               handlePossibleCancellationInterrupt(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在FutureTask中的run方法，我们需要关注两个地方，第一个，就是上面代码片段的①处，这里调用了mWorker中的call方法，这样我们再回头来看mWorker中的call方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">            public Result call() throws Exception &#123;</span><br><span class="line">                mTaskInvoked.set(true);</span><br><span class="line"></span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                //noinspection unchecked</span><br><span class="line">                return postResult(doInBackground(mParams));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Result postResult(Result result) &#123;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">       Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">               new AsyncTaskResult&lt;Result&gt;(this, result));</span><br><span class="line">       message.sendToTarget();</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在mWorker中call方法中主要就是执行耗时操作，正是doInBackground方法，并且将执行的结果result返回回去，用postResult对doInBackground进行包裹则是为了运用Handler机制来更新UI。<br>接下来我们看FutureTask中run方法中的②处，调用了FutureTask自己的set方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void set(V v) &#123;</span><br><span class="line">        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            outcome = v;</span><br><span class="line">            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state</span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void finishCompletion() &#123;</span><br><span class="line">       // assert state &gt; COMPLETING;</span><br><span class="line">       for (WaitNode q; (q = waiters) != null;) &#123;</span><br><span class="line">           if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123;</span><br><span class="line">               for (;;) &#123;</span><br><span class="line">                   Thread t = q.thread;</span><br><span class="line">                   if (t != null) &#123;</span><br><span class="line">                       q.thread = null;</span><br><span class="line">                       LockSupport.unpark(t);</span><br><span class="line">                   &#125;</span><br><span class="line">                   WaitNode next = q.next;</span><br><span class="line">                   if (next == null)</span><br><span class="line">                       break;</span><br><span class="line">                   q.next = null; // unlink to help gc</span><br><span class="line">                   q = next;</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //① 调用了FutureTask中的done方法</span><br><span class="line">       done();</span><br><span class="line"></span><br><span class="line">       callable = null;        // to reduce footprint</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>由set方法，调用finishCompletion，主要看finishCompletion的逻辑，我们只关注finishCompletion代码的①处，这里调用了done方法，<br>这样我们来看done方法中的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void done() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;An error occured while executing doInBackground()&quot;,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; catch (CancellationException e) &#123;</span><br><span class="line">                    postResultIfNotInvoked(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>在Future中调用了postResultIfNotInvoked，其实这里将这段处理逻辑抽取到方法中去了，在android2.3即以前的源码都是没有抽取的，这也是使得现在的逻辑更加清晰。<br>==java.util.concurrent.atomic.AtomicBoolean （ 在这个Boolean值的变化的时候不允许在之间插入，保持操作的原子性==）<br>由于在mWorker中的call和在mFuture的done方法都会调用postResult来更新UI，由于是线程操作，不能保证先后顺序，所以需要使用AtomicBoolean来保持操作的原子性。其实在2.3上的代码不是这样处理的，2.3上将更新UI的操作都放在mFuture中的done方法中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void postResultIfNotInvoked(Result result) &#123;</span><br><span class="line">        final boolean wasTaskInvoked = mTaskInvoked.get();</span><br><span class="line">        if (!wasTaskInvoked) &#123;</span><br><span class="line">            postResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们来看postResult方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Result postResult(Result result) &#123;</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">              new AsyncTaskResult&lt;Result&gt;(this, result));</span><br><span class="line">      message.sendToTarget();</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里就是我们非常熟悉的代码了，使用Message发送消息给Handler来更新UI。<br>在AsyncTask中定义了一个InternalHandler，如果耗时操作执行完毕，就会执行finish(result.mData[0])，如果结果正在执行，则会onProgressUpdate来更新进度，这个onProgressUpdate正是我们前面说到的需要实现的更新进度的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static class InternalHandler extends Handler &#123;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            AsyncTaskResult result = (AsyncTaskResult) msg.obj;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case MESSAGE_POST_RESULT:</span><br><span class="line">                    // There is only one result</span><br><span class="line">                    result.mTask.finish(result.mData[0]);</span><br><span class="line">                    break;</span><br><span class="line">                case MESSAGE_POST_PROGRESS:</span><br><span class="line">                    result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>AsyncTaskResult类的只是一个封装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">  private static class AsyncTaskResult&lt;Data&gt; &#123;</span><br><span class="line">      final AsyncTask mTask;</span><br><span class="line">      final Data[] mData;</span><br><span class="line"></span><br><span class="line">      AsyncTaskResult(AsyncTask task, Data... data) &#123;</span><br><span class="line">          mTask = task;</span><br><span class="line">          mData = data;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void finish(Result result) &#123;</span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            onCancelled(result);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //////耗时操作执行完毕，更新UI///////////</span><br><span class="line">            //onPostExecute运行在主线程</span><br><span class="line">            onPostExecute(result);</span><br><span class="line">            //////////////////////////////////////////</span><br><span class="line">        &#125;</span><br><span class="line">        mStatus = Status.FINISHED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>##############################################################</p>
<p>这样我们关于AsyncTask的流程终于走通了，为什么onPreExecute和onPostExecute运行在主线程，而doingBackGround为什么运行在子线程中，这个逻辑是不是就变得清晰了。上面贴了好多代码，一直都是在分析代码的意思，至于关于设计的思想感觉现在的自己还体悟不够。</p>
<ol start="4">
<li>AsyncTask在上面遗留的问题</li>
</ol>
<hr>
<p>关于AsyncTask中executeOnExecutor中的sDefaultExecutor</p>
<p>项目中问题场景：</p>
<p>操作步骤&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
<ul>
<li>设置安全中，选择指纹。</li>
<li>解锁方式选择图案。</li>
<li>在选择您的图案界面，点击确定，需要三到五秒才能跳转到下一界面。</li>
</ul>
<p>问题分析：在设置解锁方式为为图案时，第二次绘制图案后，Settings源码中使用了AsyncTask来将一些比较耗时的验证操作放在子线程中去处理(参看下面的部分代码)，由于android原生设计是使用<br>AsyncTask中的一个参数的方法，一个参数的方法采用的是默认的执行器，即串行执行器</p>
<p>==frameworks/base/core/java/com/android/internal/widget/LockPatternChecker.java==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static AsyncTask&lt;?, ?, ?&gt; verifyPattern(final LockPatternUtils utils,</span><br><span class="line">            final List&lt;LockPatternView.Cell&gt; pattern,</span><br><span class="line">            final long challenge,</span><br><span class="line">            final int userId,</span><br><span class="line">            final OnVerifyCallback callback) &#123;</span><br><span class="line">        AsyncTask&lt;Void, Void, byte[]&gt; task = new AsyncTask&lt;Void, Void, byte[]&gt;() &#123;</span><br><span class="line">            private int mThrottleTimeout;</span><br><span class="line">            @Override</span><br><span class="line">            protected byte[] doInBackground(Void... args) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    return utils.verifyPattern(pattern, challenge, userId);</span><br><span class="line">                &#125; catch (RequestThrottledException ex) &#123;</span><br><span class="line">                    mThrottleTimeout = ex.getTimeoutMs();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            protected void onPostExecute(byte[] result) &#123;</span><br><span class="line">                callback.onVerified(result, mThrottleTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ////////////默认使用的串行的执行器//////////////</span><br><span class="line">        task.execute();</span><br><span class="line">        ///////////////////////////////////////////////</span><br><span class="line">        return task;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</span><br><span class="line">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static class SerialExecutor implements Executor &#123;</span><br><span class="line">        final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">        Runnable mActive;</span><br><span class="line"></span><br><span class="line">        public synchronized void execute(final Runnable r) &#123;</span><br><span class="line">            mTasks.offer(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        r.run();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        scheduleNext();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            if (mActive == null) &#123;</span><br><span class="line">                scheduleNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected synchronized void scheduleNext() &#123;</span><br><span class="line">            if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h5 id="我们发现SerialExecutor即是串行执行器，它的作用是保证任务执行的顺序，也就是它可以保证提交的任务确实是按照先后顺序执行的。它的内部有一个队列用来保存所提交的任务，保证当前只运行一个，这样就可以保证任务是完全按照顺序执行的。如果发现异步任务还未执行，可能被我们发现SerialExecutor即是串行执行器顺序的使用线程执行。因为应用中可能还有其他地方使用AsyncTask，所以到我们的AsyncTask也许会等待到其他任务都完成时才得以执行而不是调用executor-之后马上执行。"><a href="#我们发现SerialExecutor即是串行执行器，它的作用是保证任务执行的顺序，也就是它可以保证提交的任务确实是按照先后顺序执行的。它的内部有一个队列用来保存所提交的任务，保证当前只运行一个，这样就可以保证任务是完全按照顺序执行的。如果发现异步任务还未执行，可能被我们发现SerialExecutor即是串行执行器顺序的使用线程执行。因为应用中可能还有其他地方使用AsyncTask，所以到我们的AsyncTask也许会等待到其他任务都完成时才得以执行而不是调用executor-之后马上执行。" class="headerlink" title="我们发现SerialExecutor即是串行执行器，它的作用是保证任务执行的顺序，也就是它可以保证提交的任务确实是按照先后顺序执行的。它的内部有一个队列用来保存所提交的任务，保证当前只运行一个，这样就可以保证任务是完全按照顺序执行的。如果发现异步任务还未执行，可能被我们发现SerialExecutor即是串行执行器顺序的使用线程执行。因为应用中可能还有其他地方使用AsyncTask，所以到我们的AsyncTask也许会等待到其他任务都完成时才得以执行而不是调用executor()之后马上执行。"></a>我们发现SerialExecutor即是串行执行器，它的作用是保证任务执行的顺序，也就是它可以保证提交的任务确实是按照先后顺序执行的。它的内部有一个队列用来保存所提交的任务，保证当前只运行一个，这样就可以保证任务是完全按照顺序执行的。如果发现异步任务还未执行，可能被我们发现SerialExecutor即是串行执行器顺序的使用线程执行。因为应用中可能还有其他地方使用AsyncTask，所以到我们的AsyncTask也许会等待到其他任务都完成时才得以执行而不是调用executor()之后马上执行。</h5></blockquote>
<p>如果executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,params)则不一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * An &#123;@link Executor&#125; that can be used to execute tasks in parallel.</span><br><span class="line">    */</span><br><span class="line">   public static final Executor THREAD_POOL_EXECUTOR</span><br><span class="line">           = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</span><br><span class="line">                   TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<h5 id="API中的解释：能够并行的执行任务。THREAD-POOL-EXECUTOR是一个数量为corePoolSize的线程池，具体线程池的数量是依据CPU的核心来设置的，如果超过这个数量的线程个数就需要等待"><a href="#API中的解释：能够并行的执行任务。THREAD-POOL-EXECUTOR是一个数量为corePoolSize的线程池，具体线程池的数量是依据CPU的核心来设置的，如果超过这个数量的线程个数就需要等待" class="headerlink" title="API中的解释：能够并行的执行任务。THREAD_POOL_EXECUTOR是一个数量为corePoolSize的线程池，具体线程池的数量是依据CPU的核心来设置的，如果超过这个数量的线程个数就需要等待"></a>API中的解释：能够并行的执行任务。THREAD_POOL_EXECUTOR是一个数量为corePoolSize的线程池，具体线程池的数量是依据CPU的核心来设置的，如果超过这个数量的线程个数就需要等待</h5></blockquote>
<p>SerialExecutor是按顺序执行，THREAD_POOL_EXECUTOR则一定程度上能保证并行执行。</p>
<p>以上就是关于AsyncTask的全部内容，希望能对你有些帮助，贴了好多源码，如果想真正弄清楚，还是得自己去阅读阅读源码，整理这个也不容易，前前后后花了大概一个星期。<br>最后是AsyncTask的时序图，画的不太好，凑合看吧，O(∩_∩)O哈哈~<br><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/AsyncTask.png" alt="AsyncTask时序图"></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Android">
    <span class="tag-code">Android</span>
  </a>

  <a href="/tags#AsyncTask">
    <span class="tag-code">AsyncTask</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2019/03/22/关于TabLayout的indicator宽度的一次探索/">
        <span class="nav-arrow">← </span>
        
          关于TabLayout的indicator宽度的一次探索
        
      </a>
    
    
      <a class="nav-right" href="/2020/05/21/android启动流程分析/">
        
          android启动流程分析
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js" repo issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#如上代码，一般使用AsyncTask只要重写里面的三个方法，onPreExecute和onPostExecute不是抽象方法，不是必须实现，实现这两种方法一般能让代码的逻辑更加清晰。onPreExecute运行在主线程中，做一些准备工作。onPostExecute同样运行在主线程中，用于在耗时操作完成后，更新UI。另外，还有一个onProgressUpdate方法，用于在后台任务执行过程中来实时地更新UI。"><span class="toc-nav-text">如上代码，一般使用AsyncTask只要重写里面的三个方法，onPreExecute和onPostExecute不是抽象方法，不是必须实现，实现这两种方法一般能让代码的逻辑更加清晰。onPreExecute运行在主线程中，做一些准备工作。onPostExecute同样运行在主线程中，用于在耗时操作完成后，更新UI。另外，还有一个onProgressUpdate方法，用于在后台任务执行过程中来实时地更新UI。</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#doingBackGround则是抽象方法，必须实现，我们使用AsyncTask时希望将一些耗时操作放在子线程中，doingBackGround中逻辑就相当于我们在Thread-Handler中Thread中的run方法中实现的逻辑。"><span class="toc-nav-text">doingBackGround则是抽象方法，必须实现，我们使用AsyncTask时希望将一些耗时操作放在子线程中，doingBackGround中逻辑就相当于我们在Thread-Handler中Thread中的run方法中实现的逻辑。</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#execute方法用于启动执行任务"><span class="toc-nav-text">execute方法用于启动执行任务</span></a></li></ol><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#AsyncTask的execute方法"><span class="toc-nav-text">AsyncTask的execute方法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#AsyncTask的构造方法"><span class="toc-nav-text">AsyncTask的构造方法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#FutureTask中的run方法"><span class="toc-nav-text">FutureTask中的run方法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#我们发现SerialExecutor即是串行执行器，它的作用是保证任务执行的顺序，也就是它可以保证提交的任务确实是按照先后顺序执行的。它的内部有一个队列用来保存所提交的任务，保证当前只运行一个，这样就可以保证任务是完全按照顺序执行的。如果发现异步任务还未执行，可能被我们发现SerialExecutor即是串行执行器顺序的使用线程执行。因为应用中可能还有其他地方使用AsyncTask，所以到我们的AsyncTask也许会等待到其他任务都完成时才得以执行而不是调用executor-之后马上执行。"><span class="toc-nav-text">我们发现SerialExecutor即是串行执行器，它的作用是保证任务执行的顺序，也就是它可以保证提交的任务确实是按照先后顺序执行的。它的内部有一个队列用来保存所提交的任务，保证当前只运行一个，这样就可以保证任务是完全按照顺序执行的。如果发现异步任务还未执行，可能被我们发现SerialExecutor即是串行执行器顺序的使用线程执行。因为应用中可能还有其他地方使用AsyncTask，所以到我们的AsyncTask也许会等待到其他任务都完成时才得以执行而不是调用executor()之后马上执行。</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#API中的解释：能够并行的执行任务。THREAD-POOL-EXECUTOR是一个数量为corePoolSize的线程池，具体线程池的数量是依据CPU的核心来设置的，如果超过这个数量的线程个数就需要等待"><span class="toc-nav-text">API中的解释：能够并行的执行任务。THREAD_POOL_EXECUTOR是一个数量为corePoolSize的线程池，具体线程池的数量是依据CPU的核心来设置的，如果超过这个数量的线程个数就需要等待</span></a></li></ol>
    
  </li></div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'JasonGaoH.github.io/2019/03/23/深入分析AsyncTask/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>






    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2023 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>

  </body>
</html>