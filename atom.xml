<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonGao Thoughts</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="JasonGaoH.github.io/"/>
  <updated>2023-10-19T13:03:56.028Z</updated>
  <id>JasonGaoH.github.io/</id>
  
  <author>
    <name>JasonGaoH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>孟加拉出差之旅</title>
    <link href="JasonGaoH.github.io/2023/10/13/bussiness-trip-to-BD/"/>
    <id>JasonGaoH.github.io/2023/10/13/bussiness-trip-to-BD/</id>
    <published>2023-10-13T08:13:41.000Z</published>
    <updated>2023-10-19T13:03:56.028Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间，去孟加拉出差了一趟。</p><p>长这么大，第一次出国，这篇文章记录下一些见闻和感受。</p><h3 id="出差前"><a href="#出差前" class="headerlink" title="出差前"></a>出差前</h3><p>之前我对孟加拉的印象就是孟加拉虎了，其他我了解的不多，地图上和缅甸是挨着的，另外之前偶尔在B 站上刷到的视频，只知道这个地方比较落后。一开始说要出差去那边，我内心其实是拒绝的，当身边人知道我要去孟加拉的时候，都说让我保护好自己，毕竟最近缅北的诈骗在国内引起了很大的关注。</p><p>整个出差旅程为期5天，往返都是从昆明转机的。</p><p>在飞往达卡（孟加拉首都）的飞机上，就能闻到属于这个国家的特有的那种香味，好像这个地方喜欢喷这种香水，在那边超市逛的时候就发现有个服务员在货架旁狂喷香水。</p><h3 id="到达达卡办签证"><a href="#到达达卡办签证" class="headerlink" title="到达达卡办签证"></a>到达达卡办签证</h3><p>快到达卡机场的时候，特地在飞机上面拍了一张照。<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230917_152421.jpg" alt></p><p>可以看到，房子分布还是比较密集的，给人的感觉是比较乱，不会像国内一些城市那样比较整齐一点。</p><p>到了达卡机场，整体感觉机场应该不大，相应的机场的设施还是比较差的，相较于国内来说，从机场的卫生间就能看出来，表现就是没有那么干净以及冲水设备也比较差。</p><p>接下来就是办签证了，到了办签证的地方有个哥们帮忙，比如交钱要准备什么，办签证要准备什么，他让我们在办签证这里排队，他帮我们交钱。</p><p>排队的时候拍了一张照，当时拍照的时候还被工作人员发现了，他告诉我不要拍照。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230917_140824.jpg" alt></p><p>排队了排了好一会，才将签证办好，不得不说他们这个效率还是很低的。</p><p>办完签证后，我们在旁边用人民币换了一些当地的货币，塔卡，汇率是1:15，400块人民币换了6000 塔卡。<br>其实正常情况下可以不用换的，如果有Visa的信用卡的话，超市或者饭店基本上都可以刷卡。</p><p>接着出机场，机场门口有好多办手机卡的地方，然后正好用换的钱买了一个当地的卡，具体多少钱有点忘记了，反正记得不贵，说是 4.5 G，装上了看了一下，网速也还可以。</p><h3 id="在路上"><a href="#在路上" class="headerlink" title="在路上"></a>在路上</h3><p>机场离酒店有八九公里的样子，公司有个人开车来接我们几个人的，在路上拍了个照。<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picwx_camera_1694942859631.jpg" alt></p><p>可以看到路上的车还是挺多的，这边都是右陀车，因为之前属于英联邦管辖过，这些都继承过来了。另外一个特点就是，没有红绿灯，街上各种车，汽车，三轮车，摩托车到处都是，表现就是交通会比较拥挤，遇到路口就是谁厉害谁先过。</p><p>酒店的名字叫 Amari 查了一下一晚上要一百多美金，还是比较贵的，但酒店相对国内的酒店就性价比很低了，国内这个价位可以住特别好的酒店了。<br>在酒店休息了一下，就出来吃饭了，特地下了个 Uber 来打车，打车一般也要等好久，而且他们的车牌号貌似用的不是阿拉伯数字，有点看不懂，和司机电话沟通了好一会。</p><p>下面这是在路上拍的一些照片，有些建筑感觉造的还是可以的，不过也可以理解，毕竟是首都。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230917_175952.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230917_172544.jpg" alt></p><p>看下面这张图，可以看到街上有好多这种人力的三轮车，真的很多，之前从同事那边了解到，这种车一般只需要50塔卡就可以，如果换算成人民币就是3块多点，算是挺便宜的了。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230917_174147.jpg" alt></p><p>终于坐上 Uber的车了，结果因为堵车给我们绕了一个大圈，好像是车多，没有地方可以掉头😢</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picwx_camera_1694951294059.jpg" alt></p><p>当天晚上吃的是Steakout，算是当地的一个西餐馆，我们去的时候没啥人，没有拍饭馆的照片，我们几个人点餐的时候和服务员沟通了好久，另外，就是等了好久才上菜，简单拍了一下我点的牛排。<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230917_190520.jpg" alt></p><p>我主要点了一个牛排，蘑菇以及土豆，主要我们几个对他们也不是很了解，也不知道什么好吃，我们一行人吃完都觉得一般吧，勉强填报肚子，主要上菜太慢了，等了一个多小时。</p><p>吃完饭，准备走回酒店，地图上显示十多分钟左右，感觉和打的时间差不多，而且打的还要等好久。</p><p>随手拍了一下路上的广告牌：<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230917_200737.jpg" alt></p><h3 id="办公区域"><a href="#办公区域" class="headerlink" title="办公区域"></a>办公区域</h3><p>后面几天大致的活动范围都是在公司和酒店附近了，公司离酒店没多远，就过个河的距离。</p><p>早上是8点多到公司，下午4点多有的人就下班了，也有一部分人是6点左右下班，但是6点之后基本上公司都没有人了。</p><p>下班的时候拍了一下他们的办公环境照片，感觉还可以，环境挺好的:<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230921_173714.jpg" alt></p><p>和当地技术的同学也一起拍了个照：<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_2798.HEIC.JPG.jpg" alt></p><p>在公司楼上拍了几张外面的风景照片：<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230918_074330.jpg" alt><br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230918_135559.jpg" alt></p><p>这个视角来看，整体看起来还是可以的，有水有楼有树。</p><h3 id="吃饭"><a href="#吃饭" class="headerlink" title="吃饭"></a>吃饭</h3><p>下面这张图是公司的员工餐，算是local food了，卖相看着不行，但是吃起来还可以，我自己感觉有点辣，主要是鱼和鸡肉加了一些土豆。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230919_131107.jpg" alt></p><p>另外吃的一个local food就是下面这个了，是业务带我们出去吃的，算是一个比较有名local food 餐厅了，这里只拍了一部分，吃起来味道还可以，主要比想象中好吃。<br>对于街边的小吃，听当地同事的意思是尽量别吃，外地人不适应的话很容易生病，所以我们基本都是去饭馆，也没有选择点外卖。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230920_141718.jpg" alt></p><p>其他去吃的应该都不是当地的食物了，简单放几张图，感受一下。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230918_195354.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230918_130922.jpg" alt><br>不得不说这个汉堡的肉是真厚，吃的时候油都滴下来了。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230919_190424.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230920_193453.jpg" alt></p><p>下面这张是其中一个餐馆里面，环境看起来还可以，印象中这家的饭菜也挺好吃的。<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picwx_camera_1695301848640.jpg" alt></p><p>咖啡馆：<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230921_184816.jpg" alt></p><h2 id="坐人力三轮车"><a href="#坐人力三轮车" class="headerlink" title="坐人力三轮车"></a>坐人力三轮车</h2><p>出差那周周四晚上，吃完晚饭，碰上下大雨，等了好久还是没有停的迹象。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picwx_camera_1695307922550.jpg" alt></p><p>用Uber打车打了好久没等到，我们几个人决定坐三轮车回酒店。</p><p>我和另外一个同事一起坐同一辆车，坐车上的时候拍了两张照片。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230921_212352.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230921_212640.jpg" alt></p><p>这个骑三轮车的哥们就穿了个反光背心，也不打伞，就这样冒雨给我们送到了酒店，路上碰到一个陡坡，骑不上去，他是下来把三轮车推上去的。</p><p>那个时候就觉得生活真是不容易啊，他们每天都在干这个工作，而且收入还特别低，正常情况下一趟50 塔卡左右，换成人民币3块多点。</p><p>后面下车的时候，收车费的时候他要收200 塔卡，看着他也不容易，又是下大雨，我们也没说啥，200就200吧，换成人民币的话也没有多少钱。</p><h3 id="逛商场"><a href="#逛商场" class="headerlink" title="逛商场"></a>逛商场</h3><p>周五当地同事是居家办公，因为他们下午一般需要做祷告，基本上都不来办公室。</p><p>于是，我们周五上午就去旁边的超市和商场逛了会。</p><p>下面是商场里的卖珍珠的地方，从当地同事那里了解到，珍珠算是当地的特产，看着也没有很贵，就分别给我老婆，我妈和丈母娘买了一个，每个大概200人民币左右。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230922_100826.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picwx_camera_1695356773270.jpg" alt></p><p>然后在超市里买了一些当地的零食，给儿子买了一个三轮车玩具，看起来这个三轮车玩具在国内不是很常见，会特别一点，没想到回到家才发现上面写的是 Made in China。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picwx_camera_1695354441874.jpg" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>整个出差旅程下来，大部分都是在公司和酒店这两个范围活动，远一点就是中午或者晚上去吃饭的时候了，其他的地方也没有怎么逛。</p><p>对于孟加拉当地的情况还是了解的比较有限，也没有时间出去逛，因为都是工作日时间，这应该算是达卡生活的一小部分吧。</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何轻松更新公众号文章</title>
    <link href="JasonGaoH.github.io/2023/09/12/how-to-publish-artiles-to-wechat-easily/"/>
    <id>JasonGaoH.github.io/2023/09/12/how-to-publish-artiles-to-wechat-easily/</id>
    <published>2023-09-12T12:31:18.000Z</published>
    <updated>2023-10-08T12:25:36.409Z</updated>
    
    <content type="html"><![CDATA[<p>虽然博客写的不多，但我自己的写作流程是先使用 VSCode 和 <a href="https://typora.io/" target="_blank" rel="noopener">Typora</a> 来写文章，一些图片则通过 <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> 上传到GitHub 上去，当这篇文章写的差不多后，会考虑发布自己的博客 <a href="https://jasongaohui.top/" target="_blank" rel="noopener">JasonGao Thoughts</a> 或者掘金，简书这种社区里去，对于掘金、简书这样的平台，是支持Markdown 语法的，唯一麻烦的点就是这些平台会将文章中的外部图片上传到自己的CDN上去，以提升文章的渲染速度，这也无可厚非。</p><p>但是，对于微信公众号来说，则有很多麻烦的点，第一个，就是微信公众好默认不支持 Markdown 语法，第二点，就是针对外部的图片，很多时候需要自己手动上传到公众号后台，然后才能从后台进行选择，最后，就是微信公众号的样式，有时候一个小的改动就会导致样式变得很奇怪。</p><p>之前自己在样式这一块都是使用 <a href="https://doocs.gitee.io/md/" target="_blank" rel="noopener">公众号 Markdown 编辑器</a> 这个网站来弄的，综合体验下来，如果要自己手动编辑的话，就属这个网站最好用了，而且样式整体感觉也不错。</p><p>但是这些需要手动编辑的还是让人很痛苦，尤其涉及到图片的部分，通常我的博客里面，图片就是一个 CDN 地址，但是在公众号里面要一个一个手动上传。</p><p>前一阵子，看到这篇文章 <a href="https://catcoding.me/p/publish-to-wechat/" target="_blank" rel="noopener">如何无痛苦更新公众号</a>，突然就发现这个才是我真正想要的。</p><p>作者在 GitHub 上开源了这部分的脚步 <a href="https://github.com/chenyukang/markdown-to-wechat" target="_blank" rel="noopener">markdown-to-wechat</a>，我整体看了一下，凭借我这基本没怎么写过 Python 的菜鸟水平（主要是在 ChatGPT 的帮助下），理解并稍微改了一些东西，终于将这个脚步跑通了，感谢作者提供这么好用的工具。</p><p>整体脚步没那么复杂，理解起来没那么复杂，我自己主要是在前期安装一些依赖的库花了一些时间。</p><p>现在的流程就是，当我的文章完成后，一般会推到 自己的私人 GitHub Repo 里面去，我在自己的服务器里面去拉取一下最新的博客代码，执行 sync.py 这个脚步，就可以将文章自动同步到微信的草稿里面去，基本上不需要做什么改动，就可以将文章在公众号后台发布。</p><p>目前还没有做到完全自动话，我理解我自己手动执行一下脚步成本不高，其实可以考虑监听 GitHub Actions 再来执行脚步，暂时先这样，有时间再看下。</p><p>需要注意的是，脚步中有一些需要使用公众号的开发工具，需要使用 APPID 和 AppSecret 来获取 token 来调用公众号后台的一些接口，这部分可以配置在你自己服务器的环境变量里面去，目前脚步中是从系统环境变量获取的，另外还需要设置访问下面这里设置IP白名单，只有在这里配置了白名单才可以访问相关接口,这个在下面的 仓库的 README 中也有相应的说明。<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202309122106783.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202309131707770.png" alt></p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分享一些好用的 Chrome 插件</title>
    <link href="JasonGaoH.github.io/2023/09/12/some-useful-chrome-extensions/"/>
    <id>JasonGaoH.github.io/2023/09/12/some-useful-chrome-extensions/</id>
    <published>2023-09-12T12:22:37.000Z</published>
    <updated>2023-10-11T12:59:18.136Z</updated>
    
    <content type="html"><![CDATA[<p>分享一些我觉得比较好用的 Chrome 插件，算是珍藏多年的东西了😄。</p><blockquote><p>首先是关于浏览器 Tab 相关的插件。</p></blockquote><h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><p><a href="https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca" target="_blank" rel="noopener">Momentum</a> 非常好看的 New Tab Page 插件，主要是美化 New Tab 页面，喜欢这个插件的原因是每天会生成一张好看的图片，一版是世界各个地方的风景图，质量一般都很高，让你使用浏览器的时候心情舒畅。<br> <img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picpic202309142034225_optimized.png" alt></p><p> 除此之外，还有一些工具比如 TOOD 管理，显示最常访问的网站等功能，可以按需开启。</p><h3 id="OneTab"><a href="#OneTab" class="headerlink" title="OneTab"></a>OneTab</h3><p><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="noopener">OneTab</a> 可以一键将浏览器的 Tab 收拢到第一个 Tab 下面，根据我自己的使用体验来说，大多数时候， OneTab 下面的页面重新再访问的不多，但是有时候遇到某些页面你发现很重要，需要回头，OneTab 的优势就体现出来了。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202309142037348.png" alt></p><h3 id="The-Great-Suspender"><a href="#The-Great-Suspender" class="headerlink" title="The Great Suspender"></a>The Great Suspender</h3><p><a href="https://chrome.google.com/webstore/detail/the-great-suspender-notra/ahkbmjhfoplmfkpncgoedjgkajkehcgo" target="_blank" rel="noopener">The Great Suspender</a> 可以将一些长时间没有使用的网页进行回收，但不会直接关闭，当你切回来的时候，点击一下页面即可重新加载，这样可以减少资源的占用。</p><h3 id="Popup-Tab-Switcher"><a href="#Popup-Tab-Switcher" class="headerlink" title="Popup Tab Switcher"></a>Popup Tab Switcher</h3><p>有时候，我们想使用快捷键方便的切换到浏览器的另一个 Tab，而不是每次都要使用鼠标去点一下，使用快捷键可以切换最近的几个浏览器 Tab。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202310112057942.png" alt><br>这个时候你就需要考虑这个插件了<a href="https://chrome.google.com/webstore/detail/popup-tab-switcher/cehdjppppegalmaffcdffkkpmoflfhkc" target="_blank" rel="noopener">Popup Tab Switcher</a>。<br>这个插件支持 Alt + Y 来切换最近的几个 TAB 。</p><h3 id="Chrome同步助手"><a href="#Chrome同步助手" class="headerlink" title="Chrome同步助手"></a>Chrome同步助手</h3><p>在没有科学上网的情况下，无法使用 Chrome 的同步功能，这个插件主要是用来解决这个问题的。</p><h3 id="Adblock-Plus"><a href="#Adblock-Plus" class="headerlink" title="Adblock Plus"></a>Adblock Plus</h3><p>屏蔽广告，不说了，好用。</p><h3 id="crxMouse"><a href="#crxMouse" class="headerlink" title="crxMouse"></a>crxMouse</h3><p>浏览器手势，可以通过鼠标的滑动方向来进行浏览器页面的前进和后退，向上滚动，向下滚动等。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202309150959592.png" alt></p><h3 id="FeHelper"><a href="#FeHelper" class="headerlink" title="FeHelper"></a>FeHelper</h3><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202310091045664.png" alt><br>前端开发都知道的工具，里面有一些小的工具可以安装，里面有些比较常用的工具，如 JSON 格式化等。</p><h3 id="Hypothesis"><a href="#Hypothesis" class="headerlink" title="Hypothesis"></a>Hypothesis</h3><p>网页标注工具，高亮、评论，并且配合 Obsidian 的<a href="https://github.com/weichenw/obsidian-hypothesis-plugin" target="_blank" rel="noopener">Hypothesis Obsidian同步插件</a>同步到 Obsidian 中去。<br><a href="https://x.com/jasongaohui/status/1689256626342219776?s=20" target="_blank" rel="noopener">网页标注工具 Hypothesis</a></p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202310100955860.png" alt></p><h3 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h3><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202310091956849.png" alt><br>GitHub 的代码浏览工具，可以支持在网页上类似文件管理器的方式看 Github 仓库的代码。GitHub 之前的版本是不支持以文件管理器的方式看代码的，那个时候这个工具算是神器了，现在 GitHub 已经支持这个功能了，所以用的不多了，但是也还没删除掉。</p><h3 id="Grammarly"><a href="#Grammarly" class="headerlink" title="Grammarly"></a>Grammarly</h3><p><a href="https://app.grammarly.com/" target="_blank" rel="noopener">Grammarly</a></p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202310092000642.png" alt></p><p>在浏览器里输入英文的时候会自动检查你的输入的英文是否正确，对于经常需要进行英文书写的兄弟很需要。<br>另外，最新的 Grammarly 也有Android 和 iOS 版本了。</p><h3 id="Immersion-translator-沉浸式翻译"><a href="#Immersion-translator-沉浸式翻译" class="headerlink" title="Immersion translator 沉浸式翻译"></a>Immersion translator 沉浸式翻译</h3><p>主要功能是支持翻译整个网页，功能类似彩云小译，目前基础的翻译是免费的，而彩云小译用了几次之后再用就需要付费了。<br>这个体验下来，功能还是很强大的。</p><p>下面这张图是使用该插件对 <a href="https://news.ycombinator.com/" target="_blank" rel="noopener">Hacker News</a> 整个网页的翻译，很强大。<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202310092003370.png" alt></p><h3 id="沙拉查词"><a href="#沙拉查词" class="headerlink" title="沙拉查词"></a>沙拉查词</h3><p>支持选中单词，自动显示 popup，点击即可进行翻译，另外下面的插件 Trancy 也有这个功能，但是功能相对比较简单，沙拉查词支持将生词保存下来，同时可以同步到 Anki 里面去。<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202310092008054.png" alt></p><p>下面这个是沙拉查词的设置页面，功能还是比较多的，很多东西支持配置，目前很多功能我还没有完全用到。<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202310092013116.png" alt></p><h3 id="Trancy-AI沉浸翻译和YouTube-Netflix双字幕"><a href="#Trancy-AI沉浸翻译和YouTube-Netflix双字幕" class="headerlink" title="Trancy AI沉浸翻译和YouTube/Netflix双字幕"></a>Trancy AI沉浸翻译和YouTube/Netflix双字幕</h3><p>Trancy主要是针对 Youtobe的字幕翻译，相对 CCViewer 体验会好一点，有多种展现形式，比如剧场模式和练习模式，可以使用这个来提升自己的英语能力。<br>下图则是使用 Trancy 翻译 Youtobe 英文视频的一个界面：<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202310092015639.png" alt></p><h3 id="Voice-Control-for-ChatGPT"><a href="#Voice-Control-for-ChatGPT" class="headerlink" title="Voice Control for ChatGPT"></a>Voice Control for ChatGPT</h3><p>当你安装完这个插件，会在ChatGPT 底部生成一个录制音频的按钮，按住按钮你就可以和ChatGPT 进行对话了，可以使用它来练习英语口语。<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202310092020612.png" alt></p><h3 id="篡改猴"><a href="#篡改猴" class="headerlink" title="篡改猴"></a>篡改猴</h3><p>大名鼎鼎的油猴，可以安装各种脚本，支持各种不同的功能。<br>脚本一般可以在这个平台进行安装，有很多比较使用的功能，<a href="https://greasyfork.org/zh-CN/scripts" target="_blank" rel="noopener">Greasy Fork</a>。<br>比较常用的如 网盘直链获取，全网VIP视频去广告，百度文库下载器等。<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202310112058748.png" alt></p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分享一些提升效率的工具</title>
    <link href="JasonGaoH.github.io/2023/09/06/some-efficient-tools-for-sharing-md/"/>
    <id>JasonGaoH.github.io/2023/09/06/some-efficient-tools-for-sharing-md/</id>
    <published>2023-09-06T12:54:33.000Z</published>
    <updated>2023-09-08T05:08:10.945Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名程序员，每天都要与电脑打交道，一些小的工具，真的对于工作体验是有很大的提升。</p><p>最近开始将之前用的一个青轴键盘换成了茶轴的，之前的青轴键盘还是毕业那会买的，用了也有好多年了。而且自己真实感受了一下，感觉还是茶轴会舒服一点，尤其对于我们这种大部分时间都在敲键盘的。</p><p>另外，自己还买了个键盘托，现在每天感觉敲键盘挺爽的，哈哈，应该早一点买这套装备的。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picIMG_20230908_123544.jpg" alt></p><p>这篇文章主要是想分享一些小的工具吧，一些用起来能提升幸福感的小工具。</p><h3 id="输入法相关"><a href="#输入法相关" class="headerlink" title="输入法相关"></a>输入法相关</h3><p>关于输入法软件，之前在网上刷到这个<a href="https://dvel.me/posts/rime-ice/" target="_blank" rel="noopener">雾凇拼音</a>，好奇进去看了一下，看了一下自己配置了一下，感觉现在打字挺舒服的，主要是有很多有意思的配置。</p><p>首先Rime是一个输入法引擎，Mac上对应的输入法是Squirrel，其他平台也有自己对应的软件，其实之前很早就知道这么个工具，但自己一直没有怎么尝试，而<a href="https://dvel.me/posts/rime-ice/" target="_blank" rel="noopener">雾凇拼音</a>这里主要是一些修改过的配置，作者给予Rime的配置修改了一些东西，不需要自己从头配置，用目前这套配置就可以，不需要自己去修改过多的配置即可，安装也比较简单。</p><p>除此之外，找到了一些自动切换输入法的工具，比如在Terminal和Android Studio中，主要是在使用英文输入法，通过输入法工具进行配置，针对某些软件，帮助你自动切换输入法，这样在各个软件切换的时候就不需要做那些额外的工作了。</p><p>目前主要使用的输入法切换工具是：<a href="https://keyboardholder.leavesc.com/en-us/" target="_blank" rel="noopener">KeyboardHolder</a><br>类似的还有另外还有一个软件<a href="https://github.com/Hammerspoon/hammerspoon" target="_blank" rel="noopener">hammerspoon</a><br>这个最早是在下面这篇文章发现的<a href="https://dvel.me/posts/hammerspoon-auto-change-input-method/" target="_blank" rel="noopener">Hammerspoon 自动切换输入法</a><br>我自己尝试了一下hammerspoon 发现有点不是很少用，不知道是不是我自己配置的有问题。</p><p><a href="https://inputsource.pro/zh-CN" target="_blank" rel="noopener">InputSource Pro</a> 同样也是Mac上的一款输入法切换的工具,感觉和KeyboardHolder差不多，因为是付费的，体验了一段时间就没有再用了。</p><h3 id="Mac-上那些被忽略但很好用的快捷键"><a href="#Mac-上那些被忽略但很好用的快捷键" class="headerlink" title="Mac 上那些被忽略但很好用的快捷键"></a>Mac 上那些被忽略但很好用的快捷键</h3><p>另外是考虑对Mac上的按键进行修改，之前习惯的操作是将 CapsLock键 与 Ctrl键的位置替换了，因为CapsLock用的频率很低，通常需要输入大写字母的时候按Shift就可以了，而CapsLock键原本的位置按起来特别方便，这样能有效提升一些组合键的按键效率。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202309062049217.png" alt></p><p>需要注意的是修改外接键盘和Mac自身的键盘的时候是分开设置的，之前自己一直错误的以为外接键盘的按键是改不了的。</p><p>还有就是输入法的手动切换，现在改成了Ctrl + J，因为Ctrl键现在改成了CapsLock的位置，所以这样切换输入法就变得特别方便了。</p><p>Mac 上的一些被忽略的快捷键，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picPasted%20image%2020230802150259.png" alt></p><p>用的比较多的是Cltr + A，回到行首，相当于Home键的作用，Ctrl + E 回到行末，相当于End键的作用。<br>Ctrl + F，光标前进，Ctrl + B，光标回退，还有就是Ctrl + P，往前翻页，Ctrl + N，往后翻页。<br>这些快捷键的作用是主要是让你在进行一些切换的时候，手指不需要挪动位置去按Home/End，和各个方向键，减少不必要的动作切换。</p><h3 id="一些适合-Android-开发者的工具"><a href="#一些适合-Android-开发者的工具" class="headerlink" title="一些适合 Android 开发者的工具"></a>一些适合 Android 开发者的工具</h3><h4 id="反编译工具jadx"><a href="#反编译工具jadx" class="headerlink" title="反编译工具jadx"></a>反编译工具jadx</h4><p><a href="https://github.com/skylot/jadx" target="_blank" rel="noopener">jadx</a> 这款反编译工具真的是太好用了，应该很多 Android 开发都知道这个吧，这里就不做过多的赘述了。</p><h4 id="adb的一些工具"><a href="#adb的一些工具" class="headerlink" title="adb的一些工具"></a>adb的一些工具</h4><p>作为移动端开发，免不了要抓包，常用的抓包工具就是 Charles 了，抓包就需要在手机上设置代理，每次都是输入代理的IP地址，然后输入端口，华为手机还得输入一个域名，虽然简单，但是这些工作就很麻烦，而且是无意义的重复工作。这里针对Android 设备可以考虑使用adb 这个工具来设置代理。</p><p>下面是一个shell脚步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">addres=&quot;:0&quot;</span><br><span class="line">echo ($* &gt; 0)</span><br><span class="line"></span><br><span class="line">if [ $* &gt; 0 ]</span><br><span class="line">then</span><br><span class="line">ip=$(ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1 |head -n 1 | awk &apos;&#123;print $2&#125;&apos;)</span><br><span class="line">adb shell settings put global http_proxy $ip:$1</span><br><span class="line">echo &quot;代理设置成功，代理地址为:$ip:$1&quot;</span><br><span class="line">else</span><br><span class="line">adb shell settings put global http_proxy $addres</span><br><span class="line">echo &quot;代理取消成功&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>将这个shell脚步配置到环境变量中，每次<br>输入命令 + 端口就可以设置代理了，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic202309081250450.png" alt><br>移除代理，之间执行这个命令，不需要输入端口即可。</p><p>这里需要注意的地方是，需要在开发者权限里面打开“USB调试（安全设置）”，即允许abd修改你手机的一些配置。</p><p>在zsh配置里面设置了一些别名，比如 boundson 就可以将手机查看布局边界功能打开，boundsoff 可以将其关闭 。</p><p>通过别名的方式可以把一些比较长的命令配置成简单的别名，提升输入效率，下次再用的时候可以快速执行，比如打开代码工程主目录等。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/pic202309081259184.png" alt></p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>最近的博客换了个样式，感觉比之前的要舒服不少，主题来自于<a href="https://github.com/yanm1ng/hexo-theme-vexo" target="_blank" rel="noopener">hexo-theme-vexo</a>,现在这边工作相对之前的团队没有那么忙了，加上家里小朋友也慢慢大了点，自己的时间也相对充裕了一点，后面重新开始更新一些博客，内容各种都有吧。</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mac上你一定要装的效率神器</title>
    <link href="JasonGaoH.github.io/2022/05/06/awsome-tools-in-mac/"/>
    <id>JasonGaoH.github.io/2022/05/06/awsome-tools-in-mac/</id>
    <published>2022-05-06T14:51:58.000Z</published>
    <updated>2023-09-05T12:02:35.491Z</updated>
    
    <content type="html"><![CDATA[<p>今天想介绍一下Mac上的效率神器 — Alfred。</p><p>其实关于Alfred的介绍有很多，但我还是忍不住想介绍一下这个工具，个人感觉它真的是Mac上一个特别好用的提升效率的工具了。</p> <a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_1.jpg" alt></p><p>Alfred 和Mac自带的Spotlight都属于同一类工具，但是比Spotlight 功能却要强大很多，下面会慢慢介绍它的强大之处。</p><p>Alfred 默认是使用Alt+空格键触发的，这里你也可以按照你的习惯修改启动的默认快捷键。</p><h3 id="基础功能中我觉得比较好用的"><a href="#基础功能中我觉得比较好用的" class="headerlink" title="基础功能中我觉得比较好用的"></a>基础功能中我觉得比较好用的</h3><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><p>在唤起Alfred之后，输入’ 符号或者按下空格就可以进行文件搜索，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_2.jpg" alt></p><p>文件搜索配合下面Alfred中封装的一些通用操作对于文件的操作会特别方便。</p><p>在搜索到我们需要的文件时，这个时候只需要按下→键就可以列出一些通用的操作列表，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_3.jpg" alt></p><p>Alfred 中封装了很多对于文件的操作，可以看到图中有很多，常用的比如打开，在Finder中打开，在当前位置打开终端，拷贝文件路径等等，真的是非常方便。</p><h4 id="网页搜索"><a href="#网页搜索" class="headerlink" title="网页搜索"></a>网页搜索</h4><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_4.jpg" alt></p><p>这个里面支持的搜索就很多了，我这边比较常用的就是Google和youtobe搜索了，通过在Alfred中输入google和youtobe就可以触发相应的搜索功能了，你只需要输入相应的关键字就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_5.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_6.jpg" alt></p><h4 id="剪贴板历史"><a href="#剪贴板历史" class="headerlink" title="剪贴板历史"></a>剪贴板历史</h4><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_7.jpeg" alt></p><p>Alfred 能够记录剪贴板历史，有时候我们需要查看之前剪贴板中的内容，这个功能用的相对不多，但是关键时刻还是特别管用的。</p><h4 id="Snippets-摘要功能"><a href="#Snippets-摘要功能" class="headerlink" title="Snippets(摘要功能)"></a>Snippets(摘要功能)</h4><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_8.jpeg" alt></p><p>Snippets 的功能类似TextExpander ，就是使用剪短字符来扩展大段的文字，对于一些比较模式化的文本，我们经常要输入，但是因为很长，输入很费时，如果你将这些文本存在某个地方还要花时间去搜索，这个时候，就可以通过配置Snippet来实现这个功能。其实mac系统自带的也有类似的功能，就是系统自带的Text Replacement，如下图所示，比如输入msd可以提示帮你补全”马上到！”的文本。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_13.jpeg" alt></p><h4 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h4><p>通过键盘输入相关的命令控制Mac的睡眠，启动等等，另外还可以通过输入hide来隐藏某个软件，输入quit来关闭某个软件，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_14.jpg" alt><br>这个功能用的不多，更多的是要对电脑进行息屏等操作的时候比较方便，不需要记一些快捷键，也不需要使用鼠标去进行点击，相对鼠标，键盘肯定是效率要高不少的。</p><h3 id="高级功能workflow"><a href="#高级功能workflow" class="headerlink" title="高级功能workflow"></a>高级功能workflow</h3><p>workflow是Alfred高级功能，是需要付费才能用的，我觉得这个是 Alfred 最牛逼的地方了，网上有很多好用的Workflow，因为有了自定义Workflow的功能，所以，只要你想，你可以将日常中几乎所有模板化的流程设计成你自己的workflow。</p><p>我用的比较多的workflow有以下几个。</p><p><a href="https://github.com/wensonsmith/YoudaoTranslator" target="_blank" rel="noopener">有道翻译</a>，输入yd即可进行单词的翻译，另外需要注意的是有道的翻译需要注册有道智云的账号，在workflow里设置你的应用id和密钥才可以使用</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_9.png" alt></p><p><a href="https://github.com/cj1128/alfred-qrcode-workflow" target="_blank" rel="noopener">二维码生成</a>，输入qr 再输入文本回车即可以将目标文本生成二维码，我在平时开发中经常需要构造一个二维码进行扫码调试，这个workflow让生成二维码的效率大大提高。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_10.jpeg" alt></p><p><a href="https://github.com/sballin/alfred-search-notes-app" target="_blank" rel="noopener">搜索备忘录里的一些文本</a>，输入nb则可以搜索进行文本内容的搜索，输入nt进行hashtag的搜索。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picalfred_11.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天想介绍一下Mac上的效率神器 — Alfred。&lt;/p&gt;
&lt;p&gt;其实关于Alfred的介绍有很多，但我还是忍不住想介绍一下这个工具，个人感觉它真的是Mac上一个特别好用的提升效率的工具了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>第6篇文章，这周在读什么</title>
    <link href="JasonGaoH.github.io/2022/04/20/what-do-I-read-this-week/"/>
    <id>JasonGaoH.github.io/2022/04/20/what-do-I-read-this-week/</id>
    <published>2022-04-20T15:11:35.000Z</published>
    <updated>2023-09-04T09:36:42.519Z</updated>
    
    <content type="html"><![CDATA[<p>最近接收的负面消息有点多，有时候会有一股深深的无力感，这个时候除了在社交媒体上吐吐槽也改变不了什么，更多的是徒增自己的负面情绪而已。</p><p>后来想清楚了，有些事情改变不了就不要太过关注。正如那篇宁静祷文里写的那样，改变我能改变的，接受我不能改变的。</p><a id="more"></a><p>英文原文是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">God,</span><br><span class="line"></span><br><span class="line">Grant me</span><br><span class="line"></span><br><span class="line">the serenity to accept the thing I cannot change,</span><br><span class="line"></span><br><span class="line">the courage to change the thing I can change,</span><br><span class="line"></span><br><span class="line">and wisdom to separate the difference.</span><br></pre></td></tr></table></figure><p>翻译有很多种版本，发现下面这个翻译最好。</p><p>愿上帝赐与我宁静，好让我能接受，我无法改变的事情；</p><p>愿上帝赐与我勇气，好让我能改变，我能去改变的事情；</p><p>愿上帝赐与我睿智，好让我能区别，以上这两者的不同。</p><p>今天在整理笔记的时候，发现了FaceBook公司的一个标语，Done is better than perfect. </p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picdone_better.jpg" alt></p><p>笔记出处来自《人生护城河》这本书，作者是用这句话来激励自己坚持写作，我看到这里突然觉得这句话很好，有时候我有很多想法，但总是因为害怕自己做得不好而迟迟没有动手，但是殊不知，去完成才是最关键的。</p><p>最近看的一本书，《Show Your Work》，看的是英文版，主要是想锻炼一下自己的英文阅读能力，这本书也有中文翻译，名字叫《点子就要秀出来》。</p><p>这本书让我印象比较深刻的有以下几点：</p><p>1、多发朋友圈或者推特展示自己在做的一些事情，用有用和有趣的内容和用户进行联结，这是一种基于内容的Self-Promotion；</p><p>2、分享你拥有的，这些东西有可能对于某些人来说很有用，不需要担忧你分享的东西是否完美。就像上面说的那样，完成比完美更重要。</p><p>3、可以分享哪些东西？当在项目开始的时候，分享那些能打动你的点；当项目在进行中的时候，分享你的方法以及项目的进度；当项目完成的时候，分享你的最终产品以及你从中学到的东西。</p><p>4、分享并不会减少你的价值，反而能增加你的价值。</p><p>另外，因为最近在看不少英文的书或者文档，比如上面的《Show Your Work》，之前关于Naval的那本《The Almanack of Naval Ravikant》，还有最近在看的《How to take smart notes》，之前分享的这个网站 <a href="https://www.lesswrong.com/posts/T382CLwAjsy3fmecf/how-to-take-smart-notes-ahrens-2017" target="_blank" rel="noopener">How to take smart notes</a>只是这本书的一些总结，这些基本都是英文的，因为本人词汇量有限，我主要使用以下几种工具来帮助进行相对流畅的英文阅读。</p><p>在手机上：使用欧路词典里的跨软件取词，发现还是挺好用的。将电子书epub或pdf导入到微信读书里，通过拖动图标就可以进行单词查询翻译，并且支持自动吸边。另外，我发现手机上美区的Kindle App查单词体验也挺好的，主要问题在美区Amazon 上暂时不支持国内的信用卡，而使用礼品卡买书容易被封号，我已经被封了两个账号了🤣，搜了一圈攻略说是要使用美国的地址并使用VISA这类支持外币信用卡才可以购买，后面准备试试。<img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picWechatIMG112.jpeg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picWechatIMG110.jpeg" alt></p><p>在电脑上，一般看的都是PDF，我一般使用Alfred里的有道词典workflow进行翻译，我觉得Alfred目前用起来比较多的workflow就是这个有道字典的了，唤起Alfred，输入”yd”就可以查询单词了，效率比较高，另外有的时候我会将阅读过程中的单词记下来进行复习。这个时候Alfred这个有道词典workflow就不太方便了，这个时候我一般会用浏览器插件”沙拉查词”或”划词翻译”，使用 Roam中的插件 <a href="https://github.com/aidam38/roamsr" target="_blank" rel="noopener">roamsr</a> 来帮助记单词，roamsr 实现了 Anki中的 Spaced Repetition(间隔重复)的能力，制作卡片起来很容易，使用 <a href="https://twitter.com/hashtag/sr?src=hashtag_click" target="_blank" rel="noopener">#sr</a> 标记，然后再配合浏览器中的”沙拉查词“插件，将单词的相关解释截个图丢到 Roam 中就可以制作完善的单词卡片，复习起来也很方便。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picroamsr_1.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picroamsr_2.jpg" alt></p><p>最近在看《The Almanack of Naval Ravikant》发现 Naval 也是建议要尽量去阅读经典的书，不要去读畅销书，这个和我上一篇如何更好的阅读里的观点一样，尽量去阅读那些经历过时间考验的书籍。于是我最近去看亚当·斯密的《国富论》，目前还没有完全看完，因为内容比较多，看了一小部分，感觉还是值得一读的，很多关于经济的观点一点都不过时，后面有时间再来分享。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picNaval_reading.jpeg" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近接收的负面消息有点多，有时候会有一股深深的无力感，这个时候除了在社交媒体上吐吐槽也改变不了什么，更多的是徒增自己的负面情绪而已。&lt;/p&gt;
&lt;p&gt;后来想清楚了，有些事情改变不了就不要太过关注。正如那篇宁静祷文里写的那样，改变我能改变的，接受我不能改变的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何更好得阅读</title>
    <link href="JasonGaoH.github.io/2022/04/15/how-to-read-better/"/>
    <id>JasonGaoH.github.io/2022/04/15/how-to-read-better/</id>
    <published>2022-04-15T13:54:08.000Z</published>
    <updated>2023-09-04T11:20:57.485Z</updated>
    
    <content type="html"><![CDATA[<p>今天在看geekplux的这篇 <a href="https://geekplux.com/newsletters/14" target="_blank" rel="noopener">我获取信息的方法 -#14</a> Newsletter的时候，在感慨作者获取信息源这么丰富的同时，发现原来自己最近的几篇文章其实算不上是博客，更应该算是一种Newsletter的形式。博客通常是有主题的，而Newsletter更多的时候算是一种信息输入后的整理输出，通常有多个主题。</p><p>相对Newsletter来说，博客需要更多的时间去整理，去思考，而对于我每天10105的上班节奏来说，没有太多时间去整理输出类似博客这种相对有深度的文章。</p><p>接下来，每周更多的是分享的一些Reading List，内容涉及书籍，博客，Newsletter，Twitter或YouTube等形式。</p><p>这周讲讲如何更好的阅读。</p><a id="more"></a><p>Farnam Street上的两篇文章：</p><ul><li><a href="https://fs.blog/reading/" target="_blank" rel="noopener">Reading Better</a></li><li><a href="https://fs.blog/remember-books/" target="_blank" rel="noopener">How to remember what you read</a></li></ul><p>如何更好得阅读，有以下一些技巧：</p><ul><li>我们要学会筛选好书和坏书，我们的时间是宝贵的，坏书不值得我们浪费时间，而好书值得我们反复阅读。</li><li>阅读有4个境界，为了娱乐阅读，为了了解阅读，为了理解阅读，为了掌握阅读。这个其实没有好坏之分，没有说为了娱乐阅读就一定比为了掌握阅读要低级，当你能从阅读中找到乐趣，这其实是个好事情。Naval就说过，阅读那些你喜欢的书直到你喜欢阅读为止。</li><li>不要关注阅读速度，阅读的关键不在速度，而在你是否从中吸收了知识。</li><li>如何选择好书？阅读经典的书，新书里面虽然有好书，但是数量不多，有很多质量不高的书，而经典的书经过时间的考验，值得花时间阅读。</li><li>记笔记能提高你的阅读效率。文章中介绍了一种记笔记的方式如下：<ul><li>在每个章节结尾写下这一章的总结或者一些特别的观点，要用自己的话写出来。</li><li>在读完一周后，再回来回顾一下之前的笔记。盖上书本，尝试用你自己的话写下来这本书的主要观点，如果你发现有点困难，再重新去看你的笔记。这其实来自于<a href="https://baike.baidu.com/item/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/50895393#:~:text=%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95%E7%9A%84,%E6%B3%A8%E9%87%8D%E4%BA%86%E8%A7%A3%E6%9F%90%E4%BB%B6%E4%BA%8B%E7%89%A9%E3%80%82" target="_blank" rel="noopener">费曼学习法</a>。</li><li>最后，将这些摘要手写抄下来或者输入到笔记工具(如EverNote)中去。</li></ul></li></ul><p>如何记住我们阅读的东西？这篇文章和上面那篇文章有些观点类似，这里就介绍一些不一样的观点。</p><ul><li>不要关注阅读的数量，要关注质量。</li><li>不要去关注那些华而不实的App或者工具，关注书本的内容即可。</li><li><p>不应该阅读让你觉得很枯燥的书，也不一定非得把某本书读完。</p></li><li><p>什么是主动阅读？你要在阅读某本书之前以及在整个阅读过程中你需要弄清楚你想在书中学到什么或者收获什么，将书中的内容和自己现有的知识进行关联，并尝试去应用这些知识。</p></li></ul><p>之前看过Jiayuan的推文总结<a href="https://twitter.com/Tisoga/status/1260430958345543687?t=L4nvHixGM2gUEj4JWHuxJw&amp;s=19" target="_blank" rel="noopener">3wh2t阅读法</a>，我觉得总结的很好，这里介绍下。</p><p>2wh2t的意思是Why，Who，What，How，Think以及Todo。</p><p>Why表示为什么阅读，也就是要带着目的去阅读，当你带着目的去阅读的时候才会促进你思考，漫无目的的阅读其实就是在浪费时间。</p><p>Who表示是谁，这本书是谁写的，以及书中介绍了哪些人物。这个点我理解不是必需的，但是如果你知道这些，比如作者写这本书的上下文，能够帮助更好得理解书本中的内容。</p><p>What表示书写的是什么，你要搞清楚书中写的是什么，比如前面说到的通过费曼学习法来帮助自己记住书中的观点。</p><p>How则表示怎么做，作者是怎么教你做的。</p><p>最后2个t，一个表示Think(思考)，一个表示Todo(行动)。读完这本书给你带来的思考是什么？每个人的阅历都是不同的，你肯定有你自己不一样的思考，而这个思考才是真正属于你自己的东西。另一个表示行动，行动才是最重要的，没有付诸行动的想法不过是你脑中的一个概念而已。</p><p>另外，上面的一些想法和之前读过的《麦肯锡精英高效阅读法》很多观点不谋而合，推荐大家去阅读这边书。</p><p>最后放一下按照2wh2t 方法总结的《麦肯锡精英高效阅读法》的思维导图，思维导图是Jiayuan制作的，我是觉得总结的很好，就放在这里了。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/pic20230904192030.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在看geekplux的这篇 &lt;a href=&quot;https://geekplux.com/newsletters/14&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我获取信息的方法 -#14&lt;/a&gt; Newsletter的时候，在感慨作者获取信息源这么丰富的同时，发现原来自己最近的几篇文章其实算不上是博客，更应该算是一种Newsletter的形式。博客通常是有主题的，而Newsletter更多的时候算是一种信息输入后的整理输出，通常有多个主题。&lt;/p&gt;
&lt;p&gt;相对Newsletter来说，博客需要更多的时间去整理，去思考，而对于我每天10105的上班节奏来说，没有太多时间去整理输出类似博客这种相对有深度的文章。&lt;/p&gt;
&lt;p&gt;接下来，每周更多的是分享的一些Reading List，内容涉及书籍，博客，Newsletter，Twitter或YouTube等形式。&lt;/p&gt;
&lt;p&gt;这周讲讲如何更好的阅读。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>分享一些有价值的博客</title>
    <link href="JasonGaoH.github.io/2022/04/09/Share-some-valuable-blogs./"/>
    <id>JasonGaoH.github.io/2022/04/09/Share-some-valuable-blogs./</id>
    <published>2022-04-09T09:06:23.000Z</published>
    <updated>2023-09-04T09:45:26.552Z</updated>
    
    <content type="html"><![CDATA[<p>这周的文章延迟了。</p><p>最近比较忙，清明节都在家里加班。</p><a id="more"></a><p>一直没想好这篇文章写啥，之前想着讲讲Alfred或者Anki的使用，发现自己目前还用的比较初级，加上这些工具大家多少都知道一点，这里就先不展开讲了。</p><p>在这个互联网时代，尤其在这个推荐算法盛行的时代，人们接受到的知识或者信息基本都是算法推给你的，这些可能是你感兴趣的，也可能是算法想投喂给你的，但是这些是不是真的有价值其实是有很大争议的，太多人困在这种”信息茧房”中。</p><p>这个时候需要我们跳出来，尝试跳出这个算法的圈。这也是为什么我现在基本不刷抖音，B站最近也不怎么刷了。</p><p>但是我不否认，这些平台上其实有很多质量很高的内容，但是很多时候我们接收到的都是一些比较吸引注意力质量并不高的内容，这些就像一个黑洞，会把你很多时间吸进去，很多人会发现刷着抖音刷着刷着时间就过去了，但这种很即时满足感会让你很容易沉迷其中。</p><p>首先，获取知识最好的渠道还是书本，这里的知识不是那些简单的信息，而是那些能启发你影响你提升你的知识。而书本是最好的载体，我理解没有之一，几乎人类所有的知识，智慧都可以被累积到书本中。</p><p>另外，一些写的比较好的博客也是很好的信息知识来源。我最近开始重新启用RSS来订阅那些个人认为质量比较高的博客，使用的软件是feedly和RSSHub，这里推荐一下我觉得质量很高的博客好了。</p><p>这个是我feedly的截图：</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picWechatIMG102.jpeg" alt></p><p><a href="http://blog.jiayuanzhang.com/" target="_blank" rel="noopener">Jiayuan Thoughts</a> 这位博主是Tik Tok的一名软件开发工程师，他的博客好久没更新了，最近他好像开始写Newsletter了，他之前的这些博客每次看我都感觉自己有新的收获，很多文章很值得阅读。</p><p><a href="https://geekplux.com/posts" target="_blank" rel="noopener">geekplux</a> 也是一名程序员，现在应该在香港工作，之前主要是看他的Newsletter了解到他的，文章质量很高，涉及的领域也很广。</p><p><a href="https://happyxiao.com/" target="_blank" rel="noopener">happyxiao</a> 最早是在B站上看他的Notion的教程关注他的，看着他的Twitter粉丝一路涨起来，感觉是一个很好的模范，从他的文章里的确收获很多。</p><p><a href="http://mindhacks.cn/" target="_blank" rel="noopener">刘未鹏</a> 思维改变生活，他的文章值得反复阅读。</p><p><a href="https://daimajia.com/" target="_blank" rel="noopener">代码家</a> 代码家本来是一名Android程序员，Android早期的时候他在GitHub写了很多知名的Android开发库，后来转行去做投资人，他的经历还是挺有意思的，文章值得一读。</p><p><a href="https://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰的网络日志</a> 阮一峰大家应该都知道的，很早就听过，最近看了他每周发出来的博客才发现他的文章质量还是挺高的，怪不得那么出名。</p><p>还有一些英文的博客：</p><p>比如Tim Ferriss博客：<a href="https://tim.blog/" target="_blank" rel="noopener">Tim Ferriss</a>，他的播客The Ferriss Show很出名，采访过很多大佬，这些大佬遍布各个领域，比如Facebook的扎克伯格，以及上篇文章分享的Naval等很多名人，他有一本书叫《巨人的工具》是将他采访的这些记录整理出了一本书，微信读书里可以看。</p><p><a href="https://fs.blog/blog/" target="_blank" rel="noopener">Farnam Street Blog</a> 这个里面的内容很丰富，比如下面这两篇：</p><ul><li><p><a href="https://fs.blog/reading/" target="_blank" rel="noopener">如何更好地阅读</a></p></li><li><p><a href="https://fs.blog/learning/" target="_blank" rel="noopener">学得更快记得更多</a></p></li><li><p><a href="https://fs.blog/mental-models/" target="_blank" rel="noopener">100个思维模型</a></p></li></ul><p>这周大部分业余都在看《The Almanack of Naval Ravikant》，因为上一篇文章有同学提问说到了这边书。书的内容主要整理自Naval的手抄，推特以及和Naval的谈话，分为两个模块，一个是关于财富，另一个主题则是幸福。这本书对于理解Naval的《How to get rich without getting lucky》很有帮助。</p><p>下面放一些目前的阅读笔记吧。</p><p>挣钱不是一件事情，而是一种技巧。</p><p>把你自己打造成产品。其实就是Naval说的你要使用杠杆，承担责任，学习独特知识，将这3者结合，通过不断努力，你就会变得富有。</p><p>If you’re looking toward the long-term goal of getting wealthy, you should ask yourself, “Is this authentic to me? Is it myself that I am projecting?” And then, “Am I productizing it? Am I scaling it? Am I scaling with labor or with capital or with code or with media?”</p><p>找到那些你能提供的不一样的东西，这个可能需要花费几十年。</p><p>钱是一种社会信用，它更够让你借用别人的时间。</p><p>销售技巧是一种形式的独特知识。</p><p>哪些东西可以被称为独特知识？这里自己英文理解有限，直接截原文了。</p><p>Sales skills </p><p>Musical talents, with the ability to pick up any instrument </p><p>An obsessive personality: you dive into things and remember them quickly </p><p>Love for science fiction: you were into reading sci-fi, which means you absorb a lot of knowledge very quickly </p><p>Playing a lot of games, you understand game theory pretty well </p><p>Gossiping, digging into your friend network. That might make you into a very interesting journalist.</p><p>每个人都是不一样的，要尝试去找到你擅长的事情，你不需要成为任何人，你要成为你自己。</p><p>要去打好基础，打好基础比学习更深入的知识更重要。</p><p>复利的形式有很多种，资本的复利只是最普通的一种。另外还有生意关系的复利，那些大公司的CEO就是因为他们构建起来的关系才让他们坐到那个位置，大家相信他，他肯定是因为做了很多成绩才让人们对他如此信任。</p><p>影响力的复利，影响力有很多范围，在公司的影响力，线下影响力，在网络上的影响力，即线上影响力。这个东西也是需要你长期去构建维护的，你只有持续不断的维护并构建这些东西，人们才会注意到你。</p><p>如果你找到了正确的事和正确的人，就加大你的投资力度。</p><p>拥有产权很重要，通过出卖自己的时间永远都不会变得富有。如果你创业开公司的话，你可以通过买股票成为一名小股东都是拥有产权的一种方式。</p><p>为自己的利益做事是有意义的。你在挣钱的同时，你也在最好你自己的工作，这是很合乎常理的。</p><p>Naval说他获得财富最多的时候是在他工作最不努力，对未来担心最少的时候。他纯粹的是觉得好玩去做事情。他告诉别人，他退休了，而不是在工作，这个时候，他才有时间做他认为最有价值的事情。</p><p>跟随你的好奇心去做事，而不是追寻热点。</p><p>杠杆的形式，人力，资本以及互联网时代的新式杠杆。</p><p>书本，媒体，电影以及代码都是新式的杠杆。</p><p>Coding, writing books, recording podcasts, tweeting, YouTubing—these kinds of things are permissionless.</p><p>好的工程师只需要写少量的正确的代码，创建少量正确的应用，就能够为公司创造很大的价值。</p><p>Learn to sell, learn to build. If you can do both, you will be unstoppable.</p><p>build的内容可以有很多种，设计，开发，制造，服务等等，有很多种定义。</p><p>另外，这里的sell 也是一个很宽泛的概念，不仅只是卖东西给顾客，还可以是营销，沟通，招聘，筹集资金，激励别人。</p><p>Naval围绕房子举了一个例子，房屋维修人员→一般承包商(为房东工作)→房地产开发商→房地产基金管理者(开发商需要找他们借钱)。</p><p>房屋维修人员这类人基本没有杠杆，因为没有Specific Knowledge很容易被替代，它们就是从雇佣他的老板那里拿钱。<br>承包商这里相对房屋维修人员又更上了一个层次，他们的杠杆就是那些为他工作的人，他们需要承担一些责任，并且他们有一些 Specific Knowledge，比如如何管理他们雇佣的这些人，如何处理当地的规章制度等。<br>再上一层就是房地产开发商，房地产开发商就是买入一些财产，土地，雇佣一些承包商，将这些财产转化成价值更高的东西。开发商需要承担更多的风险，承担更多的责任，他们有着更多的杠杆，同时也需要更多的Specific Knowledge。<br>比如他们需要知道怎么筹集资金，知道城市规划，知道房地产的发展方向等等。这比之前要难很多。最后就是房地产资本管理者，这些人拥有很强大的资本杠杆，他们需要和很多开发商打交道。</p><p>目前就记了这么多，强烈建议大家去下载看下，目前中午版还没出来，不过我看网上说中信出版社的马上要出来了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这周的文章延迟了。&lt;/p&gt;
&lt;p&gt;最近比较忙，清明节都在家里加班。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何不靠运气致富</title>
    <link href="JasonGaoH.github.io/2022/03/27/how-to-get-rich-without-getting-lucky/"/>
    <id>JasonGaoH.github.io/2022/03/27/how-to-get-rich-without-getting-lucky/</id>
    <published>2022-03-27T15:01:03.000Z</published>
    <updated>2023-08-08T11:19:27.080Z</updated>
    
    <content type="html"><![CDATA[<p>今年的第三篇文章，庆幸自己还在坚持，同时也希望后面自己能够继续坚持下去。</p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>这篇文章的主题主要是想介绍下Naval以及他的 <a href="https://twitter.com/naval/status/1002107570692112384" target="_blank" rel="noopener">How to Get Rich (without getting lucky)</a> 系列推文，即如何不靠运气致富。</p><a id="more"></a><p>Naval 是谁，这里简单做下介绍，Naval 是硅谷著名的投资人，投资了超过 200 多家初创公司，其中有 10 多个发展成了独角兽公司，包括 Uber，Twitter 等这样的知名上市公司，另外他还创立了著名的创投公司 AngelList，是一个面向初创企业的线上融资平台。</p><p>他为人们所熟知是在 18 年 5 月 31 一口气发了很多条推特，内容就是这个<a href>How to Get Rich (without getting lucky)</a>。这一事件也被称为 tweetstorm（推文风暴）。</p><h3 id="为什么写这篇文章"><a href="#为什么写这篇文章" class="headerlink" title="为什么写这篇文章"></a>为什么写这篇文章</h3><ul><li>第一个原因是我之前和朋友聊 Naval 的时候我发现很多人不知道，我觉得 Naval 分享的这些内容质量这么高，的确应该让更多的人知道。</li><li>第二个原因我觉得 Naval 的很多内容让我收获挺多的，不限于这一系列的推文，算是这几年来对我影响最大的一位大佬了。另外，<a href="https://nav.al/" target="_blank" rel="noopener">Naval 的博客</a> 也有很多质量很高的内容，大家有兴趣可以去阅读下。</li></ul><h3 id="如何不靠运气致富"><a href="#如何不靠运气致富" class="headerlink" title="如何不靠运气致富"></a>如何不靠运气致富</h3><p>接下来介绍下这系列推文的具体内容，先贴上英文，再加上我的翻译，英文能力有限，翻译的不好大家请见谅。</p><p>Seek wealth, not money or status. Wealth is having assets that earn while you sleep. Money is how we transfer time and wealth. Status is your place in the social hierarchy.</p><blockquote><p>追求财富，而不是金钱和地位。财富就是拥有资产，并且这些资产能在睡觉的时候给你挣钱。金钱是我们转移时间和财富的方式，地位是你在社会层级中的位置。</p></blockquote><p>Understand that ethical wealth creation is possible. If you secretly despise wealth, it will elude you.</p><blockquote><p>你要明白合乎道德的创造财富是可能的。如果你暗中鄙视财富，财富也会避开你。</p></blockquote><p>Ignore people playing status games. They gain status by attacking people playing wealth creation games.</p><blockquote><p>忽略那些玩地位游戏的人。他们通过攻击财富创造者来获取地位。</p></blockquote><p>You’re not going to get rich renting out your time. You must own equity - a piece of a business - to gain your financial freedom.</p><blockquote><p>你不会通过出租你的的时间来变得复用。你必须拥有产权— 商业的一部分，这样你才能获得财富自由。</p></blockquote><p>You will get rich by giving society what it wants but does not yet know how to get. At scale.</p><blockquote><p>你会通过提供这个社会想要的但是还没有人知道如何获得的东西而致富，前提是需要规模化。</p></blockquote><p>Pick an industry where you can play long term games with long term people.</p><blockquote><p>选择一个你可以与长期的人长期从事的行业。</p></blockquote><p>The Internet has massively broadened the possible space of careers. Most people haven’t figured this out yet.</p><blockquote><p>互联网极大地扩展了人们职业生涯的可能空间。但是大多数人对此一无所知。</p></blockquote><p>Play iterated games. All the returns in life, whether in wealth, relationships, or knowledge, come from compound interest.</p><blockquote><p>玩就玩复利游戏。生活中所有的回报，无论是财富、关系还是知识，都来自于复利。</p></blockquote><p>Pick business partners with high intelligence, energy, and, above all, integrity.</p><blockquote><p>挑选具有高智商、高能量的商业伙伴，最重要是诚信。</p></blockquote><p>Don’t partner with cynics and pessimists. Their beliefs are self-fulfilling.</p><blockquote><p>不要与愤世嫉俗者和悲观主义者合作。他们的信念是自我实现的。</p></blockquote><p>Learn to sell. Learn to build. If you can do both, you will be unstoppable.</p><blockquote><p>学会销售，学会创建。如果你能做到这两者，你将会变得不可阻挡（在成功的路上）。</p></blockquote><p>Arm yourself with specific knowledge, accountability, and leverage.</p><blockquote><p>用独特知识，责任感和杠杆武装你自己。</p></blockquote><p>Specific knowledge is knowledge that you cannot be trained for. If society can train you, it can train someone else, and replace you.</p><blockquote><p>独特知识是你不能通过训练获得的。如果能够通过训练来获得，其他人则可以通过训练获得从而取代你。</p></blockquote><p>Specific knowledge is found by pursuing your genuine curiosity and passion rather than whatever is hot right now.</p><blockquote><p>独特知识是通过追求你真正的好奇心和激情而来建立的，而不是通过当前的什么热点。</p></blockquote><p>Building specific knowledge will feel like play to you but will look like work to others.</p><blockquote><p>创建独特知识对你来说就像在玩，而对其他人来说则像是在工作。</p></blockquote><p>When specific knowledge is taught, it’s through apprenticeships, not schools.</p><blockquote><p>独特知识只能通过学徒制来习得而不是通过学校。</p></blockquote><p>Specific knowledge is often highly technical or creative. It cannot be outsourced or automated.</p><blockquote><p>独特知识往往是极具技术性或创造性的。它不能通过外包或者自动实现。</p></blockquote><p>Embrace accountability, and take business risks under your own name. Society will reward you with responsibility, equity, and leverage.</p><blockquote><p>拥抱责任，承担商业的风险通过你自己的名字，社会将用责任、股权和杠杆来回报你。</p></blockquote><p>The most accountable people have singular, public, and risky brands: Oprah, Trump, Kanye, Elon.</p><blockquote><p>最具责任感的人都有独一无二的，公开的，极具冒险精神的特质，例如：奥普拉，特朗普，坎耶，埃隆。</p></blockquote><p>“Give me a lever long enough, and a place to stand, and I will move the earth.”</p><p>— Archimedes</p><blockquote><p>给我一个足够长的杠杆，一个可以站立的地方，我就能翘起整个地球。— 阿基米德</p></blockquote><p>Fortunes require leverage. Business leverage comes from capital, people, and products with no marginal cost of replication (code and media).</p><blockquote><p>财富需要杠杆。商业杠杆可以从资本，人力以及复制起来没有边际成本的产品（代码和媒体）中获得。</p></blockquote><p>Capital means money. To raise money, apply your specific knowledge, with accountability, and show resulting good judgment.</p><blockquote><p>资本意味着钱。通过你的独特知识忙，你的责任感以及你对于结果的准确判断来筹集金钱。</p></blockquote><p>Labor means people working for you. It’s the oldest and most fought-over form of leverage. Labor leverage will impress your parents, but don’t waste your life chasing it.</p><blockquote><p>劳动力意味着为你工作的人。它是最古老，最受争议的杠杆形式。劳动力杠杆会给你的父母留下很深的印象，但不要浪费你的生命去追逐它。</p></blockquote><p>Capital and labor are permissioned leverage. Everyone is chasing capital, but someone has to give it to you. Everyone is trying to lead, but someone has to follow you.</p><blockquote><p>资本和劳动力是 被许可的杠杆。所有的人都在追逐资本，但总得有人给你。所有的人都想当领导，但必须有人跟随你。</p></blockquote><p>Code and media are permissionless leverage. They’re the leverage behind the newly rich. You can create software and media that works for you while you sleep.</p><blockquote><p>代码和媒体是无须授权的杠杆。他们是新贵人群的杠杆。你可以创建软件和媒体，它们可以在你睡觉的时候为你工作。</p></blockquote><p>An army of robots is freely available - it’s just packed in data centers for heat and space efficiency. Use it.</p><blockquote><p>一支机器人大军是免费提供的— 它只是装在数据中心中，以提高热量和空间效率。使用它。</p></blockquote><p>If you can’t code, write books and blogs, record videos and podcasts.</p><blockquote><p>如果你不会写代码，写书或者博客，录视频或者播客。</p></blockquote><p>Leverage is a force multiplier for your judgement.</p><blockquote><p>杠杆能成倍的增强你的判断（带来的效益）。</p></blockquote><p>Judgement requires experience, but can be built faster by learning foundational skills.</p><blockquote><p>判断需要经验，但是可以通过学习基础的技能来快速构建。</p></blockquote><p>There is no skill called “business.” Avoid business magazines and business classes.</p><blockquote><p>“商业”不是一种技能。要避免商业杂志和商业课程。</p></blockquote><p>Study microeconomics, game theory, psychology, persuasion, ethics, mathematics, and computers.</p><blockquote><p>去学习微观经济学，博弈论，心理学，说服术，伦理学，数学和计算机科学。</p></blockquote><p>Reading is faster than listening. Doing is faster than watching.</p><blockquote><p>读比听快，做比看快。</p></blockquote><p>You should be too busy to “do coffee,” while still keeping an uncluttered calendar.</p><blockquote><p>你应该没有时间来娱乐，同时你需要将你的日程安排得井井有条。</p></blockquote><p>Set and enforce an aspirational personal hourly rate. If fixing a problem will save less than your hourly rate, ignore it. If outsourcing a task will cost less than your hourly rate, outsource it.</p><blockquote><p>设定理想的个人小时费率并执行。如果解决问题所节省的费用少于你的每小时费率，忽略它。如果外包出去某个任务的成功低于你的每小时费率，将其外包出去。</p></blockquote><p>Work as hard as you can. Even though who you work with and what you work on are more important than how hard you work.</p><blockquote><p>尽你所能努力工作。即使你和谁一起工作以及你在做什么比努力工作更重要。</p></blockquote><p>Become the best in the world at what you do. Keep redefining what you do until this is true.</p><blockquote><p>在你所做事情上称为世界上最好的。不断重新定义你所做的事情，直到这是真的为止。</p></blockquote><p>There are no get rich quick schemes. That’s just someone else getting rich off you.</p><blockquote><p>这个世界上没有快速赚钱的方法，如果你想找这种方法，那你通常会让别人通过你赚钱</p></blockquote><p>Apply specific knowledge, with leverage, and eventually you will get what you deserve.</p><blockquote><p>应用你的独特知识，同时使用杠杆，最终你会得到你应得的。</p></blockquote><p>When you’re finally wealthy, you’ll realize that it wasn’t what you were seeking in the first place. But that’s for another day.</p><blockquote><p>当你最终变得富有的时候，你会意识到这不是你一开始想要的。但那是另一天了。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Naval 这一系列推文的信息量特别大，同时也有很多有价值的内容，值得我们好好理解体会。</p><p>简单总结一下，大概有以下几点比较重要。</p><ul><li>首先，需要明确的是，致富并没有快捷方法，如果我们想找这种方法，我们往往会被别人割韭菜。</li><li>第二，去拥有资产，就像《富爸爸穷爸爸》一书里富爸爸说的那样，要尽量买入资产，资产是能够在你睡觉的时候替你正确的东西。</li><li>第三，要去承担责任，承担风险，比如你愿意承担股票下跌的风险，你才会有机会获得股票上涨带来的收益。</li><li>第四，你的财富其实是价值的外在表现，而你提供的价值高低其实是由稀缺性来决定的。如果你能提供社会需要的但是大家还不知道怎么获得的东西你肯定就能够通过这个致富。</li><li>Naval 提到比较多的是 <strong>specific knowledge</strong>，独特知识。那么什么是独特知识呢？Naval的解释是独特知识不是那种有统一标准的知识，不能通过简单的训练来获得，而是通过学徒制来传授。那么如何理解这种独特知识呢？这里拿乒乓球这个体育赛事举例，为什么中国的乒乓球那么厉害，其他国家不管怎么努力都很难在中国选手面前拿到冠军。我觉得这一类的乒乓球技术就能很好的用独特知识来解释。在世界一流的那种技术对战中，有很多独特知识，里面的细节特别多，不是简单的靠训练模仿就能获得的，这个时候就需要一个好的教练来指导你，这也就是为什么大家都说要需要有一个好的教练，通过学徒制这种教学方式才能学会。</li><li>最后说下 <strong>leverage</strong>，同样Naval也提到很多次，leverage 简单翻译就是杠杆。这个杠杆不是那种狭义上的杠杆，当然也不能简单的理解为金融杠杆。Naval 认为杠杆是资本，人力以及复制起来没有边际成本的产品（代码和媒体），对于前两种杠杆来说，是要被别人授予才有的，但在在互联网时代，代码和媒体变成了一个在资本和人力以外的新式杠杆，它不需要被授予。我认为代码和媒体就是另外一种意义的资产，一个视频，一篇文章都是你的资产，它们复制起来边界成本几乎为0，并且能够在你睡觉的时候给你挣钱，前提是这些资产真正提供了由价值的东西。</li></ul><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>Naval说，要找到自己的兴趣所在，当你真正在从事你所感兴趣的事情的时候，你就像在玩，而这也是可以很好构建你独特知识的时候。这其实也印证着那句名言，兴趣是最好的老师。</p><p>记得乔布斯曾在斯坦福毕业典礼上对即将毕业的学生说过下面这段话：</p><p>I’m convinced that the only thing that kept me going was that I loved what I did. You’ve got to find what you love. And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don’t settle.</p><p>这里我直接贴下<a href="https://www.deepl.com/en/translator" target="_blank" rel="noopener">deepl</a> 的翻译，翻译得挺好的：</p><blockquote><p>我相信，唯一让我坚持下去的是我爱我的工作。你必须找到你所爱的东西。这对于你的工作和你的爱人来说都是如此。你的工作将占你生活的很大一部分，而真正满意的唯一方法是做你认为是伟大的工作。而做伟大工作的唯一方法是热爱你的工作。如果你还没有找到，请继续寻找。不要满足。就像所有的心事一样，当你找到它时你就会知道。而且，像任何伟大的关系一样，随着时间的推移，它会变得越来越好。所以继续寻找，直到你找到它。不要满足。</p></blockquote><p>希望你能找到你真正爱的东西，无论是在生活上还是在工作中！</p><p>这篇文章是在周六周日晚上家人睡觉的时候写的，因为平时下班比较晚，基本没有时间，写得比较仓促，大家见谅。在这个遍地都是短视频的时代，能耐心阅读长一点文字真的是一种可贵的品质，我想某种意义上，也是一种稀缺的能力，感谢大家的阅读！</p><p>最后的最后，如果你觉得这篇文章对你那么一点点启发，请帮忙点赞、分享下，非常感谢，你们的点赞和分享是让我能够坚持写下去的动力，再次感谢^_^！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今年的第三篇文章，庆幸自己还在坚持，同时也希望后面自己能够继续坚持下去。&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;这篇文章的主题主要是想介绍下Naval以及他的 &lt;a href=&quot;https://twitter.com/naval/status/1002107570692112384&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to Get Rich (without getting lucky)&lt;/a&gt; 系列推文，即如何不靠运气致富。&lt;/p&gt;</summary>
    
    
    
    
    <category term="财富自由" scheme="JasonGaoH.github.io/tags/财富自由/"/>
    
  </entry>
  
  <entry>
    <title>认知觉醒,开启自我改变的原动力</title>
    <link href="JasonGaoH.github.io/2022/03/25/how-to-improve-yourself/"/>
    <id>JasonGaoH.github.io/2022/03/25/how-to-improve-yourself/</id>
    <published>2022-03-25T14:19:08.000Z</published>
    <updated>2023-09-04T09:52:24.986Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://jasongaoh.github.io/2022/03/19/RoamResearch-%E4%B8%80%E6%AC%BE%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E6%9B%B4%E5%A5%BD%E6%80%9D%E8%80%83%E7%9A%84%E7%AC%94%E8%AE%B0%E5%B7%A5%E5%85%B7/" target="_blank" rel="noopener">RoamResearch,一款帮助我们更好思考的笔记工具</a>文章里提到要每周写一篇文章，类似最近比较流行的<code>Newsletter</code> 模式，公开地提出来也算是让大家监督我，从而让我可以坚持下去。<br> <a id="more"></a></p><p>从写文章这件事往前看，主要是这阵子我做的比较大的一个改变是：有时间就看书，把平时休闲娱乐的时候都用来阅读，因为阅读量的提高，所以也想着写点什么，主要是自己在看完书后的一些总结与思考，而因为有输出的诉求，从而又让自己得加大输入，这样形成一个比较良性的循环。</p><p>这段时间看了不少书，其实还是有不少收获的，今天主要讲讲这段时间让我感觉触动最大的书《认知觉醒》吧，这边书最早是在小创作的视频号里看到的，当时就好奇去微信读书里看了下，书中很多观点让我有种醍醐灌顶的感觉，后面我应该还会看第二遍的。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picrenzhi1.jpeg" alt></p><h2 id="什么是认知觉醒"><a href="#什么是认知觉醒" class="headerlink" title="什么是认知觉醒"></a>什么是认知觉醒</h2><p>人的大脑等级上分有 3 个部分：本能脑、情绪脑和理智脑。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picrenzhi2.jpeg" alt></p><p>本能脑源自爬行动物，可以类比成蜥蜴脑，主要是让爬行动物对环境快速做出本能反应，遇到危险就逃跑，遇到猎物就捕食，情绪脑源自哺乳动物，可以类比成猴子脑，情绪可以让哺乳动物趋利避害，更好地在恶劣的环境生存，而理智脑则源自灵长类动物，主管认知。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picrenzhi3.jpeg" alt></p><p>本能脑和情绪脑相对理智脑发展时间很长，在大多数情况下占主导地位，我们在生活中做的大部分决策往往源于本能和情绪，而非理智。</p><p>本能脑和情绪脑在亿万年来以来，是被生存压力塑造而成的，所以它们天性就是目光短浅，即时满足，喜欢呆在舒适区，而理智脑的思考是需要耗费大量能量的，所以人天性就有懒性，不喜欢思考。</p><p>这些所谓的天性在远古的时候是我们得以生存的巨大优势，而到了现在社会则成了我们成长过程中的巨大阻碍，所谓的认知觉醒就是让理智脑变强从而克服我们天性的过程。</p><h3 id="道理都懂，但就是做不到"><a href="#道理都懂，但就是做不到" class="headerlink" title="道理都懂，但就是做不到"></a>道理都懂，但就是做不到</h3><p>在电影《后会无期》中有一句台词，“听过很多道理，依然过不好这一生”，这个是为什么呢？因为大部分知道这些道理，但是就是不去行动。如果没有按照道理去践行，那肯定是一无所获，毕竟”纸上得来终觉浅，绝知此事要躬行”。你有很多想法，但是你不去行动，所有的道理在没有去实践之前都是一个概念而已。</p><p>凡执行力强的人都有一个习惯—立刻做。从手边能完成的简单事情开始，边做边调整，这样才容易达到最好的成功。</p><p>Nike的广告词写得就挺好，<code>Just do it</code>，直观去做就好了，有想法，先开始，不是只将想法停留在脑海中。</p><h3 id="如何坚持做那些短期内看不到效果的”无用之事”"><a href="#如何坚持做那些短期内看不到效果的”无用之事”" class="headerlink" title="如何坚持做那些短期内看不到效果的”无用之事”"></a>如何坚持做那些短期内看不到效果的”无用之事”</h3><p>大部分人坚持不下去是因为认知看不到那么远。因为人类的大脑喜欢确定性，不喜欢未知或不确定性。那些短期内看不到效果的事就有巨大的不确定性，所以很多人坚持不下去。</p><p>一个方法是养成习惯，从《微习惯》一书中获得的启示。作者斯蒂芬·盖斯为了养成好习惯，要求自己每天只做一个俯卧撑、每天只读一页书、每天只写 50 个字，这种无负担的习惯养成法最终促使他拥有了良好的身材，养成了阅读习惯，还写出了自己的书。</p><p>另外一个点事我们给自己设定目标的时候不宜太大，要学会将目标进行分解，分为一个一个的小目标，这样自己在完成每个目标的时候会有一个正向的反馈，同时也更能让自己有动力坚持下去。</p><p>爱因斯坦说过，复利是世界第八大奇迹，不到必要的时候，别去打断它。那些短期内看不到效果的”无用之事”其实就遵循复利规律，你要相信它。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picfuli.webp" alt><br>复利的曲线图很好的描述了增长情况，在前期，增长都是比较缓慢的，到了某个值之后才会有很大增长。大部分人因为认知上看不到这个点，所以在那个值来临之前就放弃了。而这也正是那些能坚持下去的人的机会。</p><h3 id="阅读是为了改变"><a href="#阅读是为了改变" class="headerlink" title="阅读是为了改变"></a>阅读是为了改变</h3><blockquote><p>很多人以为一本书只要读完，读书的过程就结束了。事实上，阅读只是整个过程的开始，阅读之后的思考、思考之后的实践比阅读本身更加重要（这里主要指非虚构类书籍）。很多人的阅读仅停留在表面，读的时候觉得这里好有道理、那里好有道理，读完之后就不闻不问了，然后迅速转移到下一本书中，这种满足于录入的阅读造成的一个直接后果便是，一段时间之后再去翻这本书就好像之前没有看过一样，所有的痕迹都烟消云散了。真正读好一本书，往往需要花费数倍于阅读的时间去思考和实践，并输出自己的东西——可能是一篇文章，也可能是养成一个习惯——这个过程比阅读本身要费力得多。</p></blockquote><p>这里直接将原文的部分截取下来，我觉得这段话已经描述得很清楚了，阅读的核心是在之后的思考和实践。</p><h3 id="关于写作"><a href="#关于写作" class="headerlink" title="关于写作"></a>关于写作</h3><p>知道并不表示真正理解，而是写出来，用自己的话将某个知识写出来，要让其他人都能看懂，这种才是真正的掌握。正如爱因斯坦说的，”如果你不能简单地解释它，你就不能很好地理解它”。</p><blockquote><p>真正希望通过写作建立影响力的人是不会完全被“稿酬”、“流量”等外部动机束缚的，他们往往是为自己的成长而写、为众人的需求而写、为长远的价值而写、为创造一个属于自己的世界而写。即使没有鲜花和掌声，他们也会坚持输出和成长，收获的反馈和奖励都只是意外和惊喜，不是必然和期待。这样的心态能让他们的笔尖持续释放力量，最终收获梦想，因为选择权始终在自己手上。</p></blockquote><p>上面这段关于写作的动机是从书中截取出来的。</p><p>作家 CJ Chilvers 写了 35 年的 newsletter，他在它的 <a href="https://www.cjchilvers.com/blog/35-lessons-from-35-years-of-newsletter-publishing?utm_campaign=%E5%8F%AF%E4%B9%90&amp;utm_medium=email&amp;utm_source=Revue%20newsletter" target="_blank" rel="noopener">35 Lessons from 35 Years of Newsletter Publishing</a> 中写到，Deliver value, not word counts. Solve someone else’s problem — the bigger the better. It’s nice if it solves your problem too. 简单翻译下就是：传递价值，而不是字数。解决别人的问题，越大的问题越好。如果同时也能解决你的问题，就更好了。</p><p>我觉得上面这两段话已经很好的写出了我想要表达的东西。我写的东西首先肯定是我自己觉得有用的，对于大家，可能有用，也可能没用，但是我尽量输出我自己觉得有价值的，暂时肯定不考虑流量的问题，更多的是提升自己的思考能力，提高自己的文字表达能力，如果对于大家在某些方面有些启发，那我觉得就算是成功的了。</p><p>另外，这本书在关于潜意识、元认知等基本概念的解读上有着独到的见解，另外在学习力、情绪力、专注力等这些具体能力的提升上都有具体可行的方法。感兴趣的可以自己亲自去阅读看看，非常不错的一本书。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇&lt;a href=&quot;https://jasongaoh.github.io/2022/03/19/RoamResearch-%E4%B8%80%E6%AC%BE%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E6%9B%B4%E5%A5%BD%E6%80%9D%E8%80%83%E7%9A%84%E7%AC%94%E8%AE%B0%E5%B7%A5%E5%85%B7/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RoamResearch,一款帮助我们更好思考的笔记工具&lt;/a&gt;文章里提到要每周写一篇文章，类似最近比较流行的&lt;code&gt;Newsletter&lt;/code&gt; 模式，公开地提出来也算是让大家监督我，从而让我可以坚持下去。&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>RoamResearch,一款帮助我们更好思考的笔记工具</title>
    <link href="JasonGaoH.github.io/2022/03/19/RoamResearch-a-tool-which-can-help-us-think-better/"/>
    <id>JasonGaoH.github.io/2022/03/19/RoamResearch-a-tool-which-can-help-us-think-better/</id>
    <published>2022-03-19T09:22:10.000Z</published>
    <updated>2023-09-04T11:15:10.447Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>上一次发公众号文章是 2020 年的 8 月 29 号，马上都快两年了，很久没更新了，真是太惭愧了。那些没取关的朋友们算是真爱了吧，或者是因为忘记在某个角落还关注着这个沉寂的没有提供什么价值的公众号，如果是因为后者，那可以考虑取关了 😂😂，咳~，开个玩笑。</p><p>虽然不应该给自己找理由，但是没有怎么更新的原因的确是因为太忙了，工作上的节奏也比之前更快了，生活上，因为去年小孩出生了，从去年 5 月份到现在，工作之外的大部分时间都是陪小孩去了，很少会有自己可以自由支配的时间。</p><p>最近这段时间想了很久，还是觉得要将之前的公众号捡起来，继续写点东西。先立个 flag，每周更新一篇，内容涉及平时的技术总结、阅读思考以及一些提升效率的技巧吧。</p><a id="more"></a><h3 id="什么是Roam-Research"><a href="#什么是Roam-Research" class="headerlink" title="什么是Roam Research"></a>什么是Roam Research</h3><p>今天主要来介绍一下<code>Roam Reseach</code>这个工具吧。之前还在小红书的时候就使用过一个月，后面因为需要付费就没有继续用了，今年年初的时候看到关于<code>Roam Research</code>的推特，没忍住花钱买了一年的会员，目前用了一段时间整体感觉还可以，下面分享一下自己的使用经验。</p><p>在分享我自己的使用经验之前，首先来介绍下<code>Roam Reseach</code>是什么？简单来说，它就是一个笔记工具，和传统的笔记工具如<code>Evernote</code>、<code>有道云笔记</code>相比，它有什么不一样呢？传统的这类笔记工具他往往是线性的，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picyoudao_note.jpg" alt></p><p><code>Roam Reseach</code>（下面都简称 Roam）的官方网站是<a href="https://roamresearch.com/" target="_blank" rel="noopener">Roam官网</a>，作者是<a href="https://twitter.com/Conaw" target="_blank" rel="noopener">Conaw</a>,目前有Web、Mac以及Windows版本，新用户可以试用一个月，后面就需要收费了，另外有免费的替代软件Obsidian和Logseq，这两个基本都是借鉴的 <code>Roam</code>的思想。</p><p>而<code>Roam</code>则是网状的，结构上有点类似于我们的神经元。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picshenjingyuan.jpg" alt></p><p>我们在使用传统笔记工具时，很多时候都是先建立一个分类，可能该分类下面还有一个小的分类，最后才是我们笔记的具体内容。而 Roam 则不是，比如笔记 A 讨论了 C 这个主题，笔记 B 也讨论了 C 这个主题，这样 A 和 B 就一起关联到 C 这个主题下面，注意这里的顺序，是先有 A 和 B，才有了 C 这个分类，这其实是一种自底向上的方法，程序员们对于这个方法应该不陌生，我们很多时候程序设计都会采用这种方法，由局部到整体逐步完善。</p><p>下面是 Roam 的知识网状图，看到这个图，有没有感觉很酷。<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picroam_graph.jpg" alt><br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picroam_network.jpeg" alt></p><p>那么<code>Roam</code>是如何实现这种网状结构的呢？主要是靠它的双向链表的能力。<code>Roam</code>使用[[]]来实现双向链表，所有被[[]] 包起来的内容会自动生成一个 page，而在这个 page 里又可以使用[[]]继续构造新的 page，这样，这两个 page 之间就构成了一个双向链表，由很多个这种双向链表组合起来，整体就形成了一个网状的结构。</p><p><code>Roam</code>每天会自动生成一个以当前日期为标题的 page。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picroam_daily_page.jpg" alt></p><p>比如我在今天自动生成的 page 的 Daily Log 下面关联了<code>Roam</code><br>而从<code>Roam Reseach</code>点进去则是下面这样的，</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picroam_research_page.jpg" alt></p><p>这里列出了所有链接到当前的内容，表示下面这些节点都是与 Roam Research 相关。</p><p>而点击右侧的[Open Graph View] 则可以从图结构上更直观地看到当前节点关联的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picroam_single_graph.jpg" alt></p><p>另外，Roam 还提供块的引用，使用(())可以实现，被(()) 包含的内容可以称之为块，这个块可以是其他 Page 里面某一句文本或一个片段，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picroam_block_ref.jpg" alt></p><p>图片中 1 所指示的部分就被两个地方引用到，2 处所显示的数字则是当前内容被引用的次数，通过点击 2 处可以实现折叠和展开这部分引用的内容。</p><p>另外，Roam 还提供一些快捷的命令，通过输入/即可显示。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picroam_command.jpg" alt></p><p>对于图片，可以直接将剪贴板中的图片进行上传，对于Twitter和YouTube也是可以解析出来的。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picroam_twitter.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picroam_youtobe.jpg" alt></p><p>当我们了解了以上一些技巧之后就日常使用就没有什么问题了。</p><h3 id="使用经验"><a href="#使用经验" class="headerlink" title="使用经验"></a>使用经验</h3><p>接下来，介绍一下平时我自己的一些使用技巧。</p><p>在每天自动生成的 page 下面，我一般会创建 Daily Log，MIT3，Tasks，Daily Reading 以及 Thinking 这 6 个节点。</p><p><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picroam_tips.jpg" alt></p><p><code>Daily Log</code> 主要是记录下每天的工作记录，主要是记录自己每天的时间花在哪里，从而提升工作效率，而不是每天浑浑噩噩不知道每天干了些啥。</p><p>这个方法主要来自这篇文章，<a href="https://betterhumans.pub/replace-your-to-do-list-with-interstitial-journaling-to-increase-productivity-4e43109d15ef" target="_blank" rel="noopener">Replace Your To-Do List With Interstitial Journaling To Increase Productivity</a>，主要思想是：通过记录日志来替代使用 TODO List，当你从一个工作切换到另一个工作的时候做下记录，写几句话描述一下上一个任务做了啥，以及下一个任务准备做啥，尽量描述清楚，而不是用几个简单的词语来描述。</p><p>原因是因为我们人的大脑是不能多线程工作的，我们需要在做当前工作的时候保持足够的专注度来提高我们整体的效率，所以我们需要在当前工作之前把上一个工作梳理下，并放空我们的大脑，让我们的大脑休息一下。</p><p><code>MIT3</code> 记录每天最重要的 3 件事，每天将这个里面的事情完成那么这一天就算是目标达成了。</p><p><code>Tasks</code> 记录每天的一些任务，很多时候同时会有多个事情过来，如果不记录下来则很容易忘。</p><p><code>Daily Reading</code> 则是记录每天的一些阅读记录，包括博客，文章和书籍。</p><p><code>Thinking</code> 则是记录每天的一些思考，有的可能是灵光一闪的想法。</p><p>上面就是一些 Roam 的一些实践的经验，介绍到这里，可能有人会问，我上面介绍的这些和是否使用 Roam 关系并不大啊，这些使用系统默认带的备忘录都是可以实现的啊？</p><p>嗯，这个，也不是没有道理的，重要的其实是方法，工具更多的只是辅助。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>最后，再来介绍一种使用 Roam 来记笔记的最佳实践。Roam 与其说是一个工具，倒不如说是一种思想。其实 Roam 的这种设计理念是来自德国的社会学家和系统理论家 —— 尼克拉斯 · 卢曼（Niklas Luhmann），方法名叫 Zettelkasten，卢曼使用这套方法，积累了 90000 个知识卡片，一生中写了 60 本书和其他大量出版物。</p><p>那么什么是 Zettelkasten？Zettelkasten 其实是德语，翻译成英文就是 slip-box，就是卡片盒子。<br><img src="https://cdn.jsdelivr.net/gh/JasonGaoH/Images@master/picslip_box.jpg" alt></p><p>Zettelkasten 是由许多单独的笔记组成，其中包括想法和其他简短的信息，这些信息一般是在平时学习或者思考时记下的。这些笔记可以分层编号，以便在适当的地方插入新的笔记，并包含元数据，使记录者能够将笔记相互关联。</p><p>从这个基础上，就慢慢衍生出了类似 Roam 这类的软件。在<a href="https://www.lesswrong.com/posts/T382CLwAjsy3fmecf/how-to-take-smart-notes-ahrens-2017" target="_blank" rel="noopener">How to take smart notes</a>这篇文章中就详细介绍了由 Zettelkasten 扩展出来的一种记笔记方法，写得很详细，大家有兴趣可以看看原文。</p><p>我目前主要使用以下几种类型的笔记：<br><code>Fleeting Notes</code> 记录一些临时的想法，看书过程中的一些注解等。</p><p><code>Bibliographical Notes</code> 主要是在阅读过程中的一些划线部分的摘抄，我主要是从微信读书或者 Kindle 中导出。</p><p><code>Literature Notes</code> 是用自己的话记录下阅读过的文献笔记，不能复制、粘贴，这样能迫使自己增强对于原文的理解。</p><p><code>Permanent Notes</code>则是将当前的笔记和自己之前的笔记进行关联，从而输出一个自己的全新的理解的内容，这个部分更多的是和自己之前的知识体系进行融合。</p><p>通过 <code>Roam</code> 就比较容易实现上面的这些，关键在链接，只有将新的知识融合进自己已有的知识体系，我们才算是真正掌握。</p><p>我现在会写很多 Literature Notes，主要是帮助自己去吸收理解一些知识，很多东西你以为你掌握了，但是让你用一句话说出来都不行那就不是真的掌握。不要害怕写的不对或者写的没有文采，这些都不重要，重要的是你的思考过程，写作本质上可以帮助更好地进行思考。</p><p>每个人的知识体系都是不一样的，所以我们每个人对于知识的理解也是不一样的，不要去复述别人的理解，而是要有你自己的理解，表达自己的观点，不一定对，但是得有自己的思考，这样我们的知识体系才能不断生长，不断扩张，自身才能得到成长。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;上一次发公众号文章是 2020 年的 8 月 29 号，马上都快两年了，很久没更新了，真是太惭愧了。那些没取关的朋友们算是真爱了吧，或者是因为忘记在某个角落还关注着这个沉寂的没有提供什么价值的公众号，如果是因为后者，那可以考虑取关了 😂😂，咳~，开个玩笑。&lt;/p&gt;
&lt;p&gt;虽然不应该给自己找理由，但是没有怎么更新的原因的确是因为太忙了，工作上的节奏也比之前更快了，生活上，因为去年小孩出生了，从去年 5 月份到现在，工作之外的大部分时间都是陪小孩去了，很少会有自己可以自由支配的时间。&lt;/p&gt;
&lt;p&gt;最近这段时间想了很久，还是觉得要将之前的公众号捡起来，继续写点东西。先立个 flag，每周更新一篇，内容涉及平时的技术总结、阅读思考以及一些提升效率的技巧吧。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>你可能需要这份大厂面经</title>
    <link href="JasonGaoH.github.io/2020/08/29/My-interview-in-2020/"/>
    <id>JasonGaoH.github.io/2020/08/29/My-interview-in-2020/</id>
    <published>2020-08-29T09:03:11.000Z</published>
    <updated>2023-08-08T11:19:27.081Z</updated>
    
    <content type="html"><![CDATA[<p>今年小红书这边发完年终奖之后，心里隐隐觉得要出去看看机会，因为在小红书这边已经呆了快三年了，对于一些技术，业务总觉得有点麻木了，内心里总觉得自己啥都会了，但是很多只是知道个皮毛。</p><p>有句话是这么说的，一个人在一个地方待久了，内心里以为他所处的这个环境就是全世界，所以想着做些改变，不管结果如何，至少让自己走出舒适区，同时也想着能去大厂看看。</p><a id="more"></a><p>其实大家也不能特别迷信大厂，认为加入大厂就没有后顾之忧了，只能说目前对我现在这个阶段来说，加入大厂刷一下自己的大厂背景这个对于自己当下来说还是有益的。</p><p>一开始也是不确定到底要不要出去看机会，一个是因为疫情，另一个是内心里总觉得没有准备好，其实很多事情在你开始行动的时候就没有那么多顾虑了，就像很多人在学生时代考试时一样，永远都会觉得自己没有复习好，但勇敢地迈出第一步，后面基本就没啥可恐惧的了。</p><p>自己这段时间主要就面试了三家公司吧，字节，腾讯和阿里，但经历的面试场次感觉有十来场了，有的对应的是同一公司的不同业务吧，字节面的两个业务部门都失败了，腾讯那边QQ音乐团队给了Offer，阿里这边也给了Offer，说实话，面试还是蛮累的，于是后面其他的公司也没有再尝试了。</p><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>最开始面试的是字节在上海这边的在线教育部门，这算是自己今年的第一次面试吧。</p><p>由于当时是处于一个基本没有啥准备的状态下面试的，最早是由于之前同事海哥帮忙内推的，我一开始的时候也是有点没想好是不是要面试，但因为海哥说了几次，索性我就面面看看吧，因为自己这个时间点基本是没有怎么准备，所以面试答的不怎么好，另外就是字节对于算法比较看重，我当时算法题没些出来，所以这一面基本就没有后续了。</p><p>这次主要问了以下几个问题，都是我面试完通过记忆记录下来的。</p><p>首先是自我介绍吧，介绍之前的一些经历和项目</p><ul><li>做过哪些app的性能优化</li><li>使用什么工具进行内存分析</li><li>讲讲事件拦截机制</li><li>对于网络的理解，http和https的区别</li><li>讲讲对于UI的理解</li><li>安全，怎么保证安全，除了网络层的安全，app其他地方如何保证安全</li><li>App为什么要签名</li><li>算法题，最大区间问题 已知一天内用户登录登出的日志（数据量较大），求这一天用户在线的最大峰值和持续时间段 日志包含字段（userid, login_time, logout_time） 登录登出时间精确到秒<br>从这次我也还是懒懒散散地在准备中，可能面试失败对我并没有产生多太多触动。</li></ul><p>这次面试没有后续之后，后来字节这边有个安全的团队也说是要和我聊聊，这次面试的时间是在周六，当时一共进行了两场面试，为什么是安全团队呢，因为他们看我的简历发现我是信息安全毕业的，但是说句实话，学校里学的那些关于信息安全相关的知识离工程实践还是有点远的，所以这次面试我基本上都是全程懵逼状态。</p><p>下面列举的是这次面试的一些问题：</p><ul><li>bindService的流程</li><li>应用双开的机制</li><li>第三方的权限拦截</li><li>自我hook</li><li>gps的定位模拟</li><li>imei号的伪造</li><li>socket通信 JNI 输入</li><li>WebView的读文件flag在4.4是否开启</li><li>Android中的网络通信方式有哪些</li><li>IPC的方式</li><li>广播实现IPC方式的话有什么安全隐患，需要注意什么</li></ul><p>字节这边后面还面过抖音的上海部门，这会已经是后面了，因为这时基本已经拿到腾讯的Offer了，阿里这边也还在面试流程中，所以就想着面面看看情况，这次是一个之前的同事的同事帮忙内推的，这里同样列举下问的问题：</p><ul><li>问了我简历中做的那个吸顶效果，怎么实现的</li><li>对象的创建的流程</li><li>事件分发的流程</li><li>OOM发生在哪些区域</li><li>方法区加载的类是否会被GC</li><li>startActivity的流程</li><li>开机启动的流程</li><li>RN的工作原理</li><li>fluter了解嘛</li><li>RN有些时候为什么有留白</li><li>包体积优化</li><li>Android的系统架构</li><li>小红书首页过渡严重，过度绘制的解决</li><li>优化做过哪些，数据是怎么样的</li><li>小红书笔详的引导是怎么做的</li><li>Android为什么有多进程，单进程都没有多进程通信的问题了，不挺好的嘛</li><li>双指按下去一个View不抬起将View滑出屏幕这个流程是怎么样的</li><li>yogo是干什么的</li><li>litho的原理是什么</li><li>指定start和end位置的链表的翻转</li></ul><p>相对来说，我觉得抖音的这次面试有些问题问的还是比较有难度的，加上我后面给了个算法题也还是没能写出来。所以基本上后续也没有消息了，唉，感觉自己还是太菜了。字节每一轮面试都会问一个算法，对于算法的考察应该算是大厂里面比较严格的。</p><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><p>后面有个猎头说是微信那边要招人，说是机会不错，于是我决定试试。当时想着就当增加增加面试经历吧。</p><p>后面猎头推荐后，广州那边有个人打电话过来说是要进行电话面试。我当时其实关于算法这一块还是没怎么复习，于是这次微信的面试直接上来就是笔试，我记得是5道算法题，还有一个关于多线程的编程问题，要求45分钟内完成。</p><p>大概的题目如下：</p><p>题目1（算法）：给出n(n&gt;=1)，请把1,2,…,n，最小分成m组，使得每组内的数字都互质，求m值。例如n=7，可最小划分成3组，{1, 2, 3}, {4, 5}, {6, 7}<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmin</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>题目2（算法）：给定一个递增循环整数数组，从里面找出最小的元素，使用的算法越快越好。特别地，最小的元素可能出现在数组中间。比如：50, 52, 63, 90, 3, 8, 15, 44。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Problem2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findmin</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>题目3（算法）：在二叉排序树上面找出第3大的节点。注意：不能把二叉树全量存储到另外的存储空间，比如存储到数组中，然后取出数组的第三个元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Problem3</span> </span>&#123;</span><br><span class="line">  <span class="function">TreeNode <span class="title">find</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 请完成实现部分</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>题目4（语法）：用Java语言实现System#arraycopy数组拷贝，注意：不能直接使用System.arraycopy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Problem4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 请完成实现部分</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目5（多线程）：阅读下面代码，在2线程环境下，设计一个方案，判断无限数据流(Stream)每个正整数是否素数，越快越好<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">()</span></span>; <span class="comment">// 获取下一个需判断的整数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">boolean</span> result)</span></span>; <span class="comment">// 返回整数是否素数的结果</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrimeNumber</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123; <span class="comment">// 判断一个整数是否素数</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">2</span>, s = (<span class="keyword">long</span>) Math.sqrt(num); i &lt;= s; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Stream <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (Stream) Class.forName(<span class="string">"StreamImpl"</span>).newInstance(); <span class="comment">// 运行环境保证不会异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比如：Stream=&#123;1,2,3,4,...&#125;, Result=&#123;false,true,true,false,...&#125;，注意输出顺序。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Stream stream = Stream.getInstance();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Problem instance = <span class="keyword">new</span> Problem();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          instance.thread1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          instance.thread2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 请完成实现部分</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 请完成实现部分</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为之前没准备，我当时连二叉搜索树是有序的这个概念都忘了，把二叉搜索树当做普通的二叉树去处理了，感觉当时在45分钟过后，面试官操着一口广东味的普通话来我和沟通的时候，让我当时有种直接挂断电话的冲动，总之，就感觉这次面试体验很不好，让我有种想去撞墙的冲动。</p><p>也是从这个时候开始，开始意识到要好好准备算法，不然真的是没有继续面下去的必要。</p><p>微信这边的面试基本没有后续了，答得这么差，有后续才怪咧。</p><p>后面我的简历应该是被收到腾讯的人才库里去了，于是有深圳那边的业务开始打电话给我说是要面试。</p><p>一开始是深圳的一个做SDK的部门，和我进行了一次腾讯会议的视频面试。这次基本就是聊技术，这个面试官对我的评价不错，主要聊了聊我在小红书做的一些东西和自己平时做的一些技术沉淀，然后问了一些Android相关的技术问题，觉得我的表现不错，但是因为他们是做SDK的，和我这边的经历不是特别匹配，面试官当时也直接说了可能不是特别匹配，但是他说会在面试反馈中给予我比较好的面试评价。</p><p>可能也是因为这个原因，后面我的简历又被腾讯的其他业务部门捞起来了。</p><p>首先是手机QQ团队，一面面试官问的都是一些Java和Android 基础问题，但是问的比较多，基本上各个知识点都问到了一些。</p><p>一面基本上问了下面一些问题：</p><ul><li>做过哪些内存优化</li><li>内存抖动，如何定位内存抖动</li><li>view移动用动画实现有哪些方式</li><li>自己实现区域解码，decodeFileDescriptor</li><li>scrollto 和 scrollby 的区别</li><li>内存泄漏如何分析</li><li>mvc，mvp和mvvm的区别</li><li>mvvm的缺点是什么，mvvm为啥不用DataBinding，不用DataBinding怎么实现双向绑定</li><li>leakcanary 的原理</li><li>事件冲突如何自己解决</li><li>RecyclerView和ListView的区别</li><li>Service和IntentService的区别</li><li>Service如何stop，bindService的方式如何stop</li><li>aidl 的原理</li><li>多进程通信方式</li><li>自己实现过多进程吗</li><li>HashMap的原理是什么</li><li>红黑树的原理是什么</li><li>Handler可以在多个线程里使用嘛，有几个消息队列，每个线程的消息是如何发到另一个线程的</li><li>aidl 自己写如何实现</li><li>用过哪些设计模式，设计模式</li><li><p>工厂和抽象工厂的区别（因为上面我说在项目中实践过工厂设计模式，所以他就问了工厂和抽象工厂的区别）<br>手Q二面是视频面试，问的问题是比较抽象一点，感觉一般没有固定的答案。</p></li><li><p>如果不采用改变Bitmap config的这种方式，如何做Bitmap的内存优化</p></li><li>网络优化怎么做</li><li>单元测试</li><li>硬件加速的原理，硬件加速是如何工作的</li><li>RecyclerView 滑动到item不可见后，这部分内存时是如何回收的</li><li>卡顿检测怎么做，如何上报</li><li>写个死锁的代码</li><li>假如字符串中所有字符都不重复，如何输出字符串的所有组合。例如：abc，结果应是a,b,c,ab,ac,bc,abc。</li></ul><p>二面答的问题基本没怎么答好，有的是自己不怎么涉及这些，有些则是对于某些理解不够深入。其实我觉得这次面试失败是因为这个几个问题没回答好，我能感觉到面试官有种不想继续聊下去的冲动了，后面则是象征性地出了一道算法题。</p><p>接着收到了QQ音乐的面试邀请，这次面了好几轮，一开始是那边的HR给我打了个电话，基本就是聊为啥换工作，能不能去深圳这样，以及在小红书的工作内容等等。</p><p>接着面了好几轮，两轮技术面，一轮交叉面，还有总经理面试，最后还有HR面，因为面的轮次比较多，当时对于面试题也没有特殊整理，不过大概问的问题都是这些东西，和之前的面试问题大差不差。</p><p>面到后来QQ音乐这边算是通过了，给的Offer还可以。</p><p>腾讯这边还面过腾讯视频的岗位，这个是在自己懒散的情况下进行的，因为基本确定要去哪了，当时就想着涨涨面试经验啥的。这次面试基本面试完之后我就觉得没有后续了。下面是问的一些问题：</p><p>算法题：输入[“eat”,”ate”,””tea”,”and”,”den”] 要求输出“换位词”，[[“eat”,”ate”,””tea”],[”and”],[”den”]]</p><ul><li>业务上做的有挑战性的东西是啥</li><li>RxJava底层进行数据通信的原理</li><li>RxJava和EventBus做通信的区别</li><li>线程的状态</li><li>线程的两种创建状态</li><li>线程池的种类，以及内部是如何管理线程的，什么时候创建，什么时候让线程运行</li></ul><h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><p>阿里这边就让同事认识的一个阿里员工内推了阿里的岗位，这次面的是淘宝下面的一个业务。当时是在差不多拿到QQ音乐Offer的时候开始的，当时也没有想太多，反正就是想试试，因为当时想的是，拿不到这边的机会，就去深圳工作去。</p><p>阿里的面试一面问的基本都是业务相关的，基本就是讲自己在小红书做的东西和一些Android基础知识。这几次面试我也没有做什么面试题的记录。</p><p>二面上来也是问技术啥的，后来搞了三个笔试题，一个是排序问题，一个是用栈来模拟队列，还有一个是写一个小的商品feed流的demo，难度不是特别大，关于问的一些具体的面试题我也忘了，差不多都是那些东西吧。</p><p>最后一面是HR和Leader一起的终面，Leader应该是这个业务线的领导，没有问具体的技术问题，问的都是一些比较开放的问题，阿里的这次面试整体感觉还算顺利吧，后面就是算是通过了，给了Offer。</p><p>基本上，自己面试比较顺利的几次都没有记录下来。关于Offer的选择，腾讯相对阿里，杭州相对深圳，压力要小很多，所以决定去阿里，所以就拒了QQ音乐这边的机会，但是心里还是蛮喜欢这个工作岗位的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体说来，这段时间的面试不能算是成功的，很多面试都没有通过，通过的还有运气成分在里面吧，这也提醒我自己要学习的东西还有好多吧，尤其自己在算法这一块还是比较薄弱的，对大多数人来说，算法题这块没有啥捷径吧，就是多刷题吧。</p><p>我记录这些希望能对面试的人有些帮助吧，因为之前很多人让我写面经啥的，我也不太清楚怎么写，就是把一些问题记录下来吧，如果你觉得有帮助，可以帮忙点赞分享下，感谢。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今年小红书这边发完年终奖之后，心里隐隐觉得要出去看看机会，因为在小红书这边已经呆了快三年了，对于一些技术，业务总觉得有点麻木了，内心里总觉得自己啥都会了，但是很多只是知道个皮毛。&lt;/p&gt;
&lt;p&gt;有句话是这么说的，一个人在一个地方待久了，内心里以为他所处的这个环境就是全世界，所以想着做些改变，不管结果如何，至少让自己走出舒适区，同时也想着能去大厂看看。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>快到年底的年中总结</title>
    <link href="JasonGaoH.github.io/2020/08/06/Mid-year-review/"/>
    <id>JasonGaoH.github.io/2020/08/06/Mid-year-review/</id>
    <published>2020-08-06T08:21:56.000Z</published>
    <updated>2023-08-08T11:19:27.081Z</updated>
    
    <content type="html"><![CDATA[<p>今天聊聊技术以外的话题。</p><h1 id="为什么要坚持写公众号"><a href="#为什么要坚持写公众号" class="headerlink" title="为什么要坚持写公众号"></a>为什么要坚持写公众号</h1><p>这个和<code>为什么坚持写博客</code>的问题类似，我的回答是为了进步。16年毕业，我一直在坚持写博客，早期的时候对于技术这块可能关于Activity的生命周期都能整一篇文章出来，现在有时候因为时间忙，可能好几个月才会出一篇文章，但是我还是一直在坚持着，应该以后也会一直坚持下去。</p> <a id="more"></a><p>为什么写博客或者写公众号文章能够让我们进步，简单来讲，在你写文章的时候会促进我们思考。</p><p>举个例子，我在第一家公司的时候，当时在手机设置页遇到一个UI的卡顿问题，因为牵扯代码比较偏底层，当时让我一个刚毕业的小菜鸟去分析这个问题，我当时不知道怎么分析，就问联发科那边的研发（因为当时做的是基于联发科平台的手机开发），联发科那边给的方案是是把一行代码改一下，当时改一下发现可以了，于是就兴高采烈地和老大说这个难搞的问题解决了，当时的软件老大贵哥说了句，不能因为问题解决了就觉得OK了，应该思考的是这个问题为什么这么解决，这样才能成长。</p><p>后来我特地针对这个问题写了一篇博客，对这个感兴趣的可以去看看下面这篇文章。<br><a href="https://jasongaoh.blog.csdn.net/article/details/52432736" target="_blank" rel="noopener">深入分析AsyncTask</a></p><p>这件事情一直在影响我，每当遇到问题的时候，我找到解决方法了，我都会总结一下。有的时候觉得分析的还可以，就会整理出来发成博客或者公众号文章。包括在给组内的同事看问题的时候，我始终觉得应该把这些遇到的问题当做一次成长和进步的机会，而不是因为自己忙而推诿。</p><p>很多人初级的开发经常会问，如何提升技术水平，或者问如何成长成为高级开发工程师，包括网上也有很多这样那样的课程教你如何学习，其实我的理解很简单，就是学习加总结，遇到问题不浅尝辄止，往深处看一点，并对自己遇到的问题进行梳理总结，这样的人想不提升技术都难。</p><h1 id="关于读书的一些思考"><a href="#关于读书的一些思考" class="headerlink" title="关于读书的一些思考"></a>关于读书的一些思考</h1><p>2020年快过去 60% 了<br><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/uPic/hW2Mzf.png" alt></p><p>年初的时候发推说今年要读50本书。<br><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/uPic/Twitter.jpeg" alt></p><p>现在离50本书还差很多，目前看完的或在看主要有以下这些。</p><ul><li>[麦肯锡精英读书法]</li><li>[穷查理宝典]  </li><li>[中央帝国的军事密码]</li><li>[中央帝国的财政密码]</li><li>[小岛经济学]</li><li>[人生护城河]</li><li>[软技能-代码之外的生存指南]</li><li>[硅谷钢铁侠-马斯克自传]</li><li>[商业的本质和互联网]</li><li>[富爸爸穷爸爸]</li><li>[未来简史-从智人到智神]</li></ul><p>一个对我冲击比较大是在读<code>人生护城河</code>的时候，不要拿自己固定的时间去换固定的钱，这个从长远来看是不划算的，因为你无法保证自己单位时间内的生产率一定会提高。很多人从小接受到的教育就是提高自己的专业技能，努力升职来实现加薪，但是靠升职和加薪永远都不是长久之计，巴菲特说，如果你没有找到一个当你睡觉时还能挣钱的方法，你将一直工作到死。</p><p>为什么我要思考这些，其实更多的原因是因为自己在互联网，大家都听过35岁的概念，毕竟国内的互联网环境就是这样，我也一直在想，如果等到我35岁了，没有公司愿意要我了，我将何去何从呢？</p><p>当然，肯定也有一些到了40岁还在写代码的，但是说实话，这样的人真是太少了。</p><p>在<code>人生护城河</code>这本书中，作者说，写作从长期来看就是一个滚雪球的活动，你的阅历在增加，你的写作技巧在提升，你的粉丝在增加，你的声誉在提高。每一步看似慢，但可以慢慢地持续做一生。</p><p>在<code>富爸爸穷爸爸</code>中说到，我们要尽量买入资产，资产是能够在你睡觉的时候还能给你挣钱的东西，而负债只会从你的口袋里掏钱出去。那么神秘是资产呢？普通的就是股票，债券，能够产生收入的房地产，还有就是版权，音乐、作品或者电子书。</p><p>在互联网时代，一篇文章，一个视频，都可以称为资产。据我的了解，一些在youtobe上做视频的人很多都基本告别了朝九晚五的生活，这算是一种方向吧，我觉得我会去试试的，大家也不妨试试，毕竟，做内容真的是一个成本很低的创业了。</p><p>另外，之前看过一个案例，著名的陶瓷实验，老师把学生分成两组：第一组用一个月时间每天做一个陶瓷，第二组用一个月时间只做一个陶瓷，结果是第一组学生的作品全部优于第二组学生。不管是做什么，写文章，做视频，量变都能产生质变，开始的时候肯定不容易，但是要相信，坚持下去，肯定会有收获。</p><h1 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h1><p>在小红书待了快3年了，我觉得自己也要做出些改变了，工作上总觉得自己处在一个舒适区，其实这个说的倒不是加班，互联网公司，一般加班都比较凶，很多时候在持续的忙碌中都有点麻木了。</p><p>为什么大家能看到我发的文章，因为我已经向公司提出了离职，目前正在家休假呢，不然在公司996的情况下哪有时间写文章啊，手动狗头。</p><p>因为竞业协议的缘故，关于离职也不好说太多，等后面稳定了后会专门写一篇文章聊聊这几个月的面试经历。</p><p>我也不知道出去后情况是变好还是变坏，但是不出去，谁又能知道呢？</p><p>逼自己一把，远离舒适区，大概就是这样想的吧。</p><p>2020年，注定是不平凡的一年，对世界如此，对我奕如此。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天聊聊技术以外的话题。&lt;/p&gt;
&lt;h1 id=&quot;为什么要坚持写公众号&quot;&gt;&lt;a href=&quot;#为什么要坚持写公众号&quot; class=&quot;headerlink&quot; title=&quot;为什么要坚持写公众号&quot;&gt;&lt;/a&gt;为什么要坚持写公众号&lt;/h1&gt;&lt;p&gt;这个和&lt;code&gt;为什么坚持写博客&lt;/code&gt;的问题类似，我的回答是为了进步。16年毕业，我一直在坚持写博客，早期的时候对于技术这块可能关于Activity的生命周期都能整一篇文章出来，现在有时候因为时间忙，可能好几个月才会出一篇文章，但是我还是一直在坚持着，应该以后也会一直坚持下去。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Feed流上的优化实践.md</title>
    <link href="JasonGaoH.github.io/2020/08/06/Optimization-Practices-on-Feeds/"/>
    <id>JasonGaoH.github.io/2020/08/06/Optimization-Practices-on-Feeds/</id>
    <published>2020-08-06T05:16:21.000Z</published>
    <updated>2023-08-08T11:19:27.079Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直负责小红书的关注Feed的迭代工作，因为一直是在完成新功能的迭代工作，对于Feed的性能和消费体验就没有特别关注，加上对于这块业务的一些监控也没有落地，所以长期对于这块的性能基本上就是一个忽视的状态。随着业务越来越复杂，功能越来越多，收到好多反馈都是说关注页面的滑动体验很不好，于是决定对关注Feed做一个性能优化。</p> <a id="more"></a><p>这里先从优化说起，之前在网上看到一个关于优化的分类，觉得很有道理。</p><p>请看下面这张图：<br><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/uPic/optimization_category.png" alt></p><h3 id="关于优化"><a href="#关于优化" class="headerlink" title="关于优化"></a>关于优化</h3><p>优化整体可以分为两大类，软优化和硬优化。那么什么是软优化呢？软优化并不会改变某段代码的执行效率，而是通过调整这段代码的执行时机，来优化整体代码的运行性能。软优化里由分为三大类，分别为预加载，异步加载和懒加载。</p><h4 id="软优化"><a href="#软优化" class="headerlink" title="软优化"></a>软优化</h4><ul><li>预加载<br>这几种加载方式都很好理解，改变的都是执行时机，预加载就是提前加载，把一些重要的数据提前加载好，等到合适的时机，就可以直接展示给用户，而不是在这个合适的时机才去加载数据，这种方式给用户地感觉是加载变快了。</li><li>异步加载<br>而异步加载在Android中则很常见了，移动应用中有主线程的概念，主线程需要实时地对用户的操作予以反馈，这种反馈要非常及时，否则就会让用户觉得卡顿。因此，主线程的工作不宜有耗时操作，而且对于一些执行比较慢的代码，而且不需要同步执行的代码，我们可以考虑将它放到异步线程去执行。</li><li>懒加载<br>最后就是懒加载了，懒加载就是把一些不是需要立即展示的东西往后放，因为我们的手机性能，内存是有限的，有些功能用户不是需要马上看到，则可以考虑在后续的某个适当的时机执行加载。</li></ul><h4 id="硬优化"><a href="#硬优化" class="headerlink" title="硬优化"></a>硬优化</h4><p>接下来说说硬优化，硬优化这个东西就比较偏细节了。一段逻辑，我们用两层循环实现，功能肯定是OK的，但是如果在实现功能的情况下，我们用一层循环就可以解决了，这样不就提高了这段代码的运行效率了。这种方式的优化就是硬优化了，关于硬优化往往没有具体的方法，很多都是各种见仁见智，通过调整代码的逻辑来提高运行效率都可以称为硬优化。</p><h4 id="Feed流上的问题发现和解决"><a href="#Feed流上的问题发现和解决" class="headerlink" title="Feed流上的问题发现和解决"></a>Feed流上的问题发现和解决</h4><p>很多人会说，上面说了这么多软优化和硬优化，有什么用呢？别急，我们慢慢来说。上面说的算是一种对于优化的指导思想吧，下次我们遇到类似的问题可以从这几个维度来进行分析。</p><p>我们要做优化，首先肯定是要发现问题，也就是对症下药。</p><p>我之前主要处理的是Feed流的卡顿优化，所以我基本上都是通过Android Studio的Profiler工具来查看问题，现在Profiler的体验相对之前功能算是更加强大了，我每次都是使用Profiler来尝试抓一下Feed流滑动时的代码执行情况。<br>然后一个一个查看滑动过程中我们的耗时是在哪些地方。</p><h5 id="通过Profiler发现的问题"><a href="#通过Profiler发现的问题" class="headerlink" title="通过Profiler发现的问题"></a>通过Profiler发现的问题</h5><p>通过Profiler发现了以下几点问题：</p><ol><li>发现有一些比较耗时的方法，比如图文笔记上的滤镜的回收方法比较耗时，针对这样的可以考虑做这个release操作放到异步里面去；</li><li>另外也发现一些业务的打点会在OnBindViewHolder中调用的很频繁，虽然点位数据的发送是在异步线程里，但是在发送数据之前会有数据的拼装操作，多少会有些性能损耗，而且打点这一类数据完全可以放到异步线程中去，因为这种打点并不需要很高的实时性；</li><li>对于一些跨进程的操作，比如从Context中拿Service获取WiFi状态，这种在onBind中回调是非常不好的，所以针对这个我们只需要构造一个广播来监听WIFI状态变化即可，然后每次只需要拿那个记录好的网络状态变量即可</li><li>还有关于视频笔记的处理，我们需要根据RecyclerView滑动过程中当前item中的视频start，stop和prepare做相应的调整，正常情况下，当RecyclerView处于滑动状态是不应该去prepare和start的，而且也不应该创建播放器实例和Texture View的；</li><li>最后，通过Profiler我们还发现TextView的setText是很耗时的，当我们复杂多行文本的情况时，TextView去setText的时候需要进行复杂的测量，在测量完之后还需要绘制，所以针对这个场景可以考虑使用StaticLayout对Feed流中的文本作预渲染，关于StaticLayout的教程网上也有不少，后面有时间我也会抽空写下关于这块的实践。</li></ol><p>上面都是通过Profiler来发现的一些问题。</p><h5 id="View层级"><a href="#View层级" class="headerlink" title="View层级"></a>View层级</h5><p>另外还有一些算是基础的优化吧。因为View的层级随着Feed流的业务变得越来越深，我们需要进可能地减少View的层级，同时也尽量减少View的个数，可以考虑使用ConstraintLayout，但是ConstraintLayout这个东西要慎用，对于一些迭代比较快的业务场景，使用ConstraintLayout会增加我们的维护成本，而且会有一些比较坑的问题。</p><p>关于View层级的缩减基本没啥可讲的，尽量用merge和ViewStub，这个就是根据实际情况去消除一些不必要的层级。</p><h5 id="RecyclerView缓存的利用"><a href="#RecyclerView缓存的利用" class="headerlink" title="RecyclerView缓存的利用"></a>RecyclerView缓存的利用</h5><p>最后，我们也尝试了从RecyclerView缓存的角度来解决这个问题，RecyclerView默认会有四级缓存的概念，正常情况下，当我们的RecyclerView的卡片撑满屏幕的时候，我们进入该页面的时候，我们的RecyclerView会先创建ViewHolder，然后再bind这个ViewHolder，然后当我们向下滑动的时候，会再次创建一个ViewHolder，接着再执行Bind操作，只有当我们的RecycledView Pool的池子满了之后才不会继续创建ViewHolder，往后的滑动RecyclerViwe就只会执行bind操作了，这个时候我们发现这个OnCreateViewHolder需要从xml里去解析view，并且创建这个ViewHolder，这个创建对于我们的滑动是会有性能损耗，其实还是因为我们的这个卡片太复杂了。</p><p>所以，我们可以考虑提前创建一些ViewHolder，放到ViewHolder的池子里去，这样我们在滑动的时候，就不需要先Create再Bind了。</p><p>提前创建ViewHolder，在主线程Idle的状态下提前创建ViewHolder放到RecycledViewPool中，这个pool的size默认是5。<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.setRecycledViewPool(RecyclerView.RecycledViewPool().apply &#123;</span><br><span class="line">LightExecutor.postIdle(Runnable &#123;</span><br><span class="line">repeat(<span class="number">5</span>) &#123;</span><br><span class="line"><span class="comment">//RecycledViewPool 默认size为5个，RecyclerView内部会有判断，如果满了不会create</span></span><br><span class="line"><span class="comment">//注意这里取得是typePool的倒数第一个和第二个位置，需要保证注册的时候视频卡片和笔记在最后两个位置</span></span><br><span class="line">putRecycledView(mAdapter.createViewHolder(followFeedRecyclerView, mAdapter.typePool.size -<span class="number">1</span>))</span><br><span class="line">putRecycledView(mAdapter.createViewHolder(followFeedRecyclerView, mAdapter.typePool.size -<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>在做完这些优化之后，在Feed流上的卡顿就有很大改善了，另外，对于业务侧的指标也有一定的数据提升。</p><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>对于这块业务的性能监控可以实施起来，这样有利于我们尽早发现卡顿问题，另外，对于一些优化的点其实还可以继续深挖，比如前创建ViewHolder是否可以使用AsyncLayoutInflator进行inflate，还有针对文本的预渲染可以考虑抽成组件形式，方便其他业务使用。</p><p>感谢您的阅读，如果觉得我的文章对你有帮助，请帮忙点赞，有问题可以评论留言。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前一直负责小红书的关注Feed的迭代工作，因为一直是在完成新功能的迭代工作，对于Feed的性能和消费体验就没有特别关注，加上对于这块业务的一些监控也没有落地，所以长期对于这块的性能基本上就是一个忽视的状态。随着业务越来越复杂，功能越来越多，收到好多反馈都是说关注页面的滑动体验很不好，于是决定对关注Feed做一个性能优化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="性能优化 RecyclerView缓存" scheme="JasonGaoH.github.io/tags/性能优化-RecyclerView缓存/"/>
    
  </entry>
  
  <entry>
    <title>深入解析volatile关键字</title>
    <link href="JasonGaoH.github.io/2020/05/21/how-volatile-works/"/>
    <id>JasonGaoH.github.io/2020/05/21/how-volatile-works/</id>
    <published>2020-05-21T01:17:31.000Z</published>
    <updated>2023-08-08T11:19:27.081Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章已同步发表于微信公众号JasonGaoH，<a href="https://mp.weixin.qq.com/s?__biz=MzUyNTE2OTAzMQ==&amp;mid=2247483805&amp;idx=1&amp;sn=a6240f582ec81d047a59f206f8d5ba54&amp;chksm=fa237975cd54f063470a8eb7d68774c474ddab37cf88ff16ac873b47f0ac1b514b8be8254344&amp;token=1938879438&amp;lang=zh_CN#rd" target="_blank" rel="noopener">深入解析volatile关键字</a></p></blockquote><p><code>volatile关键字</code>和<code>synchronized关键字</code>一样，在Java多线程开发中，是一道必须要跨越的槛。之前有篇文章已经分析过<code>synchronized关键字</code>的原理，<a href="https://blog.csdn.net/H_Gao/article/details/98593198" target="_blank" rel="noopener">synchronized关键字的原理</a>，这一次，我们来一步一步分析下<code>volatile关键字</code>的工作原理。</p> <a id="more"></a><p>本文篇幅稍微有点长，希望您能耐心看下去，并有所收获。</p><h3 id="volatile关键字的使用"><a href="#volatile关键字的使用" class="headerlink" title="volatile关键字的使用"></a>volatile关键字的使用</h3><p>首先，我们从一个简单的程序来入手。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileFoo</span> </span>&#123;</span><br><span class="line"><span class="comment">//init_value的最大值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//init_value的初始值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> init_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动一个Reader线程，当发现local_value和init_value不同时，</span></span><br><span class="line"><span class="comment">//则输出init_value被修改的信息</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">int</span> localValue = init_value;</span><br><span class="line"><span class="keyword">while</span>(localValue &lt; MAX) &#123;</span><br><span class="line"><span class="keyword">if</span>(init_value != localValue) &#123;</span><br><span class="line">System.out.println(<span class="string">"this init_value is updated to "</span> + init_value);</span><br><span class="line"><span class="comment">//对local_value重新赋值</span></span><br><span class="line">localValue = init_value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">"Readder"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">int</span> localValue = init_value;</span><br><span class="line"><span class="keyword">while</span>(localValue &lt; MAX) &#123;</span><br><span class="line">System.out.println(<span class="string">"this init_value will be changed to "</span> + ++localValue);</span><br><span class="line"><span class="comment">//对local_value重新赋值</span></span><br><span class="line">init_value = localValue;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">"Updater"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的程序分别启动了两个线程，一个线程负责对变量进行修改，一个线程负责对变量进行输出。</p><p>运行程序，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> init_value will be changed to <span class="number">1</span></span><br><span class="line"><span class="keyword">this</span> init_value is updated to <span class="number">1</span></span><br><span class="line"><span class="keyword">this</span> init_value will be changed to <span class="number">2</span></span><br><span class="line"><span class="keyword">this</span> init_value will be changed to <span class="number">3</span></span><br><span class="line"><span class="keyword">this</span> init_value will be changed to <span class="number">4</span></span><br><span class="line"><span class="keyword">this</span> init_value will be changed to <span class="number">5</span></span><br></pre></td></tr></table></figure><p>从输出信息我们发现，Reader线程没有感知到init_value的变化，我们期望的是在Updater进程更新init_value的值之后，Reader进程能够打印出变化的init_value的值，但结果并不是我们期望的那样。</p><p>我们尝试在init_value前面加上<code>volatile</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> init_value = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>接着我们再运行下这个程序，输出结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> init_value will be changed to <span class="number">1</span></span><br><span class="line"><span class="keyword">this</span> init_value is updated to <span class="number">1</span></span><br><span class="line"><span class="keyword">this</span> init_value will be changed to <span class="number">2</span></span><br><span class="line"><span class="keyword">this</span> init_value is updated to <span class="number">2</span></span><br><span class="line"><span class="keyword">this</span> init_value will be changed to <span class="number">3</span></span><br><span class="line"><span class="keyword">this</span> init_value is updated to <span class="number">3</span></span><br><span class="line"><span class="keyword">this</span> init_value will be changed to <span class="number">4</span></span><br><span class="line"><span class="keyword">this</span> init_value is updated to <span class="number">4</span></span><br><span class="line"><span class="keyword">this</span> init_value will be changed to <span class="number">5</span></span><br><span class="line"><span class="keyword">this</span> init_value is updated to <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>这个时候Reader线程就能够感受到init_value的值的变化了，并且在条件不满足时程序就退出了运行。</p><p>那么为什么加了个volatile就正常了呢， volatile关键字的作用到底是什么呢？</p><p>想要彻底搞清楚<code>volatile关键字</code>，还需要具备Java内存模型、CPU缓存模型、汇编指令等相关知识的，接下来，我们接下来一步一步来拆解问题。</p><h3 id="CPU缓存模型"><a href="#CPU缓存模型" class="headerlink" title="CPU缓存模型"></a>CPU缓存模型</h3><p>要想对volatile有比较深刻的理解，首先我们需要对CPU的缓存模型有一定的认识。</p><p>在计算机中，所有的运算操作都是由CPU的寄存器来完成的，CPU指令的执行过程需要涉及数据的读取和写入操作，CPU所能访问的所有数据只能是计算机的主存（通常是指RAM），虽然CPU的发展频率不断得到提升，但受制于制造工艺以及成本的限制，计算机的内存反倒在访问速度上没有多大的突破，因此CPU的处理速度和内存的访问速度之间的差距越拉越大，通常这种差距可以达到上千倍，极端情况下甚至会在上万倍以上。</p><p>由于两边速度严重的不对等，通过传统FSB直连内存的访问方式会导致CPU资源受到极大的限制，降低CPU整体的吞吐量，于是就有了CPU和主内存直接增加缓存的设计，现在缓存数量都可以增加到3级了，最靠近CPU的缓存为L1,然后依次是L2,L3和主内存，CPU缓存模型图如下所示：<br><img src="https://raw.githubusercontent.com/JasonGaoH/KnowledgeSummary/master/Docs/img/cpu_cache.png" alt="CPU缓存模型图"><br>Cache的出现是为了解决CPU直接访问内存效率低下的问题，程序在运行的过程中，会将运算所需要的数据从主内存复制一份到CPU Cache中，这样CPU计算时就可以直接对CPU Cache中的数据进行读取和写入，当运算结束之后，再将CPU Cache中最新的数据刷新到主内存当中，CPU通过直接访问Cache的方式提到直接访问主内存的方式极大地提高了CPU的吞吐能力，有个CPU Cache之后，整体的CPU和主内存之间的交互的架构大致如下图所示：<br><img src="https://raw.githubusercontent.com/JasonGaoH/KnowledgeSummary/master/Docs/img/cpu_cache_framework.png" alt="CPU与主内存交互图"></p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>由于缓存的出现，极大地提高了CPU的吞吐能力，但是同时也引入了缓存不一致的问题。在多处理器系统中，每个处理器都有自己的的高速缓存，而它们又共享同一主内存，当多个处理器的运算任务都设计到同一块内存区域时，将可能导致各自的缓存数据不一致，这个时候就需要通过<code>缓存一致性协议</code>来保证数据的正确性，不同的操作系统使用缓存一致性协议都各不相同。</p><p>因为各种硬件和操作系统的内存访问是有差异的，Java为了程序能在各种平台下运行达到一致的内存访问效果，于是定义了Java内存模型（Java Memory Mode，JMM）来对特定内存或高速缓存的读写访问过程进行抽象。</p><p>Java内存模型定义了线程和主内存之间的抽象关系，具体如下。</p><ul><li>共享变量存储于主内存之中，每个线程都可以访问。</li><li>每个线程都有私有的工作内存和本地内存。</li><li>工作内存值存储该线程对共享变量的副本。</li><li>线程不能直接操作主内存，只有先操作了工作内存之后才能写入主内存。</li><li>工作内存和Java内存模型一样也是一个抽象的概念，它其实并不存在，它涵盖了缓存、寄存器、编译优化以及硬件等。<br><img src="https://raw.githubusercontent.com/JasonGaoH/KnowledgeSummary/master/Docs/img/java_memory_model.png" alt="image"><br><code>Java内存模型</code>定义了一套主内存和工作内存的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之类的实现细节。具体有8种操作来完成，分别为lock、unlock、read、load、use、assign、store和write。除此之外，<code>Java内存模型</code>还规定在执行这8种操作的时候必须满足8种规则，由于篇幅问题，这里就不一一列举了，具体可参看深入理解Java虚拟机第12章的Java内存模型与线程。</li></ul><p><code>Java内存模型</code>是一个抽象的概念，其与计算机硬件的结构并不完全一样，比如计算机物理内存不会存在栈内存和堆内存的划分，无论是堆内存还是虚拟机栈内存都会对应到物理的主内存，当然也有一部分堆栈内存数据可能会存入CPU Cache寄存器中。具体可参考下图：<br><img src="https://raw.githubusercontent.com/JasonGaoH/KnowledgeSummary/master/Docs/img/cpu_hardware.png" alt="image"></p><h3 id="对于volatile变量的特殊规则"><a href="#对于volatile变量的特殊规则" class="headerlink" title="对于volatile变量的特殊规则"></a>对于volatile变量的特殊规则</h3><p>介绍了<code>CPU缓存模型</code>以及<code>Java内存模型</code>之后，我们再来说<code>volatile关键字</code>，这样更能加深我们对于<code>volatile关键字</code>的理解。<br><code>volatile关键字</code>是Java虚拟机提供的最轻量级的同步机制，很多人由于对它理解不够，往往更愿意使用synchronized来做同步。</p><p><code>Java内存模型</code>对<code>volatile关键字</code>定义了一些特殊的访问规则，当一个变量被volatile修饰后，它将具备两种特性，或者说volatile具有下列两层语义：</p><ul><li>第一、保证了不同线程对这个变量进行读取时的可见性， 即一个线程修改了某个变量的值， 这新值对其他线程来说是立即可见的。 (volatile 解决了线程间共享变量的可见性问题)。</li><li>第二、禁止进行指令重排序， 阻止编译器对代码的优化。</li></ul><p>针对第一点，<code>volatile</code>保证了不同线程对这个变量进行读取时的可见性，具体表现为：</p><ul><li>第一： 使用 volatile 关键字会强制将在某个线程中修改的共享变量的值立即写入主内存。</li><li>第二： 使用 volatile 关键字的话， 当线程 2 进行修改时， 会导致线程 1 的工作内存中变量的缓存行无效（反映到硬件层的话， 就是 CPU 的 L1或者 L2 缓存中对应的缓存行无效);</li><li>第三： 由于线程 1 的工作内存中变量的缓存行无效， 所以线程 1再次读取变量的值时会去主存读取。</li></ul><p>基于这一点，所以我们经常会看到文章中或者书本中会说volatile 能够保证可见性。</p><p>volatile 能够保证可见性，但是volatile不能保证程序的原子性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">race ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread[] threads = <span class="keyword">new</span> Thread[THREAD_COUNT];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;THREAD_COUNT;i++) &#123;</span><br><span class="line">threads[i] = <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt; <span class="number">10000</span>;j++) &#123;</span><br><span class="line">increase();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">threads[i].start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">Thread.yield();</span><br><span class="line"></span><br><span class="line">System.out.println(race);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。我们运行完这段代码之后，并没有获得期望的结果，而且发现每次运行程序。输出的结果都不一样，都是一个小于200000的数字。</p><p>问题就出在自增运算”race++“之中，我们用javap反编译这段代码后发现只有一行代码的increase()方法在Class文件中是由4条字节码指令构成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">     0: getstatic     #13                 // Field race:I</span><br><span class="line">     <span class="number">3</span>: iconst_1</span><br><span class="line">     <span class="number">4</span>: iadd</span><br><span class="line">     5: putstatic     #13                 // Field race:I</span><br><span class="line">     <span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>从字节码层面上很容易分析出原因了：当getstatic指令把race的值取到操作栈时，volatile关键字保证了race的值此时是正确的，但是在执行iconst_1、iAdd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈订的值就变成了过期的数据，所以putstati指令执行后就可能把较小的值同步回主内存中去了。</p><p>其实这里我们通过字节码来分析这个问题是不严谨的，因为即使编译出来的只有一条字节指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义，如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令。关于解释执行和编译执行，我们还会再讲到。</p><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（synchronized或java.util.concurrent中的原子类）来保证原子性。</p><ul><li>运输结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他状态变量共同参与不变约束。</li></ul><p>类似下面的场景就时候采用volatile来控制并发。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">shutdownRequested = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!shutdownRequested) &#123;</span><br><span class="line"><span class="comment">//do stuff</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们想让上面的那个自增操作保持原子性，我们可以使用AtomicInteger，具体程序如下，这里就不多做介绍了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//public static volatile int race = 0;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger race =<span class="keyword">new</span>  AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//race ++;</span></span><br><span class="line">race.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread[] threads = <span class="keyword">new</span> Thread[THREAD_COUNT];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;THREAD_COUNT;i++) &#123;</span><br><span class="line">threads[i] = <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt; <span class="number">10000</span>;j++) &#123;</span><br><span class="line">increase();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">threads[i].start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">Thread.yield();</span><br><span class="line"></span><br><span class="line">System.out.println(race.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>回到<code>volatile关键字</code>的第二层语义：禁止指令重排。<br>普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p><p>我们用一段伪代码来帮助下理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="comment">//此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设一下代码在线程A中执行</span></span><br><span class="line"><span class="comment">//模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processCongigOptions(configText,configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设一下代码在线程B中执行</span></span><br><span class="line"><span class="comment">//等待initialized为true，代表线程A已经吧配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span>(!initialized) &#123;</span><br><span class="line">sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure></p><p>上面这段代码如果定义的initialized没有使用volatile来修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一句代码<code>initialized = true</code>被提前执行（这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行时值这句话对于的汇编代码被提前执行），这样在线程B中使用配置信息的代码就可能出现错误，而volatile能避免此类情况的发生。</p><h3 id="volatile关键字深入解析"><a href="#volatile关键字深入解析" class="headerlink" title="volatile关键字深入解析"></a>volatile关键字深入解析</h3><p>上面讲到<code>volatile关键字的两层语义</code>，那么volatile保证可见性以及有序性到底是如何做到的呢？它的底层逻辑是什么呢？</p><p>这里我们尝试获得Java程序的汇编代码，通过比较变量加入volatile修饰和未加入volatile修饰的区别。</p><p>这里主要使用的是HSDIS插件，HSDIS是一个Sun官方推荐的HotSpot虚拟机JIT编译代码的反汇编插件，网上有关于这个插件的下载，不过有的链接已经失效，我这里是从这里获取的，<a href="https://github.com/liuzhengyang/hsdis" target="_blank" rel="noopener">hsdis</a>，再把这个clone下来之后，编译成功之后，使用下面这个命令拷贝到jre的server目录,具体可以查看这个repo中README文件，里面写的很详细。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp build/macosx-amd64/hsdis-amd64.dylib /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/server/</span><br></pre></td></tr></table></figure><p>接下来就可以尝试反汇编了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance ==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Singleton.getInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个是我们尝试反汇编的程序代码，如果是命令行，我们可以使用下面这个指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly Singleton</span><br></pre></td></tr></table></figure><p>如果是eclipse，在下图的VM arguments中添加<code>XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</code>,然后运行程序，这样在控制台就会输出汇编代码。<br><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/eclipse_jit.png" alt="image"><br>程序运行后，在控制台会输出很多内容,由于输出太大，所以截取了前面一段输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server VM warning: PrintAssembly is enabled</span>; turning on DebugNonSafepoints to gain additional output</span><br><span class="line">Loaded disassembler from /Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/server/hsdis-amd64.dylib</span><br><span class="line">Decoding compiled method <span class="number">0x0000000112e9ad50</span>:</span><br><span class="line">Code:</span><br><span class="line">[Disassembling <span class="keyword">for</span> mach=<span class="string">'i386:x86-64'</span>]</span><br><span class="line">[Entry Point]</span><br><span class="line">[Constants]</span><br><span class="line">  # &#123;method&#125; &#123;0x000000010ce1f000&#125; 'hashCode' '()I' in 'java/lang/String'</span><br><span class="line">  #           [sp+0x40]  (sp of caller)</span><br><span class="line">  <span class="number">0x0000000112e9aec0</span>: mov    <span class="number">0x8</span>(%rsi),%r10d</span><br><span class="line">  <span class="number">0x0000000112e9aec4</span>: shl    $<span class="number">0x3</span>,%r10</span><br><span class="line">  <span class="number">0x0000000112e9aec8</span>: cmp    %rax,%r10</span><br><span class="line">  <span class="number">0x0000000112e9aecb</span>: jne    <span class="number">0x0000000112de0e60</span>  ;   &#123;runtime_call&#125;</span><br><span class="line">  <span class="number">0x0000000112e9aed1</span>: data16 data16 nopw <span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br><span class="line">  <span class="number">0x0000000112e9aedc</span>: data16 data16 xchg %ax,%ax</span><br><span class="line">[Verified Entry Point]</span><br><span class="line">  <span class="number">0x0000000112e9aee0</span>: mov    %eax,-<span class="number">0x14000</span>(%rsp)</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure><p>得到这个输出之后，我使用<code>Singleton</code>全局搜索了下，发现还无结果。<br><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/XmXvXX.png" alt="image"><br>反编译的却没有得到相应的内容，这是什么问题呢？<br>带着这个问题Google了好久，终于搞明白原因了。</p><p>于是我们又要来补充些虚拟机编译的知识了。<br><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/NiZjK5.png" alt="image"><br>我们在使用<code>java -version</code>查看JDK版本的时候，可以看到最后有个<code>mixed mode</code>，这里其实表明的是Java 虚拟机的编译方式，在HotSpot虚拟机中，提供了两种编译模式：解释执行 和 即时编译（JIT，Just-In-Time），即时编译也可以称为编译执行，解释执行即逐条翻译字节码为可运行的机器码，而即时编译则以方法为单位将字节码翻译成机器码。</p><p>我们在反编译Singleton这个类的时候，因为虚拟机使用的是解释执行，这样我们是得不到汇编代码的。在深入理解Java虚拟机一书中介绍可以加上<code>-Xcomp</code>来触发JIT编译，但是我用的是JDK1.8，这个 -Xcomp`已经被移除了，具体哪个版本被移除了，目前我也没仔细研究过了。</p><p>那要怎样才能触发JIT编译呢？答案是循环。通过足够多次数的循环来触发JIT编译。我们需要确保写的Java方法被调用的次数足够多，以触发C1（客户端）编译，并大约10000次触发C2（服务器）编译器并打开高级优化。换句话说，要想查看汇编代码，我们所写的Java源代码文件不能太过于简单，要足够复杂。</p><blockquote><p>注意：C1，C2都是HotSpot虚拟机内置的即时编译器。C1：即Client编译器，面向对启动性能有要求的客户端GUI程序，采用的优化手段比较简单，因此编译的时间较短。C2：即Server编译器，面向对性能峰值有要求的服务端程序，采用的优化手段复杂，因此编译时间长，但是在运行过程中性能更好。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance ==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++) &#123;</span><br><span class="line">Singleton.getInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我在代码里加上了两层循环，然后在尝试获取一些汇编代码。</p><p>这次发现终于能得到Singleton相关的汇编代码了。</p><p>于是我们分别编译了两次，第一个是没有使用volatile关键字修饰instance，第二个是使用volatile关键字，然后我们分别取出<code>Singleton::getInstance</code>这一段来进行比较。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未使用volatile修饰</span></span><br><span class="line"> <span class="number">0x000000010d29e931</span>: movabs $<span class="number">0x7955f12a8</span>,%rsi  ;   &#123;oop(a <span class="string">'java/lang/Class'</span> = <span class="string">'main/Singleton'</span>)&#125;</span><br><span class="line"> <span class="number">0x000000010d29e93b</span>: mov    %rax,%r10</span><br><span class="line"> <span class="number">0x000000010d29e93e</span>: shr    $<span class="number">0x3</span>,%r10</span><br><span class="line"> <span class="number">0x000000010d29e942</span>: mov    %r10d,<span class="number">0x68</span>(%rsi)</span><br><span class="line"> <span class="number">0x000000010d29e946</span>: shr    $<span class="number">0x9</span>,%rsi</span><br><span class="line"> <span class="number">0x000000010d29e94a</span>: movabs $<span class="number">0xfe403000</span>,%rax</span><br><span class="line"> <span class="number">0x000000010d29e954</span>: movb   $<span class="number">0x0</span>,(%rsi,%rax,<span class="number">1</span>)  ;*putstatic instance</span><br><span class="line">                                               ; - main.Singleton::getInstance@<span class="number">24</span> (line <span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用volatile修饰</span></span><br><span class="line"> <span class="number">0x000000011435394f</span>: movabs $<span class="number">0x7955f12a8</span>,%rsi  ;   &#123;oop(a <span class="string">'java/lang/Class'</span> = <span class="string">'main/Singleton'</span>)&#125;</span><br><span class="line">  <span class="number">0x0000000114353959</span>: mov    %rax,%r10</span><br><span class="line">  <span class="number">0x000000011435395c</span>: shr    $<span class="number">0x3</span>,%r10</span><br><span class="line">  <span class="number">0x0000000114353960</span>: mov    %r10d,<span class="number">0x68</span>(%rsi)</span><br><span class="line">  <span class="number">0x0000000114353964</span>: shr    $<span class="number">0x9</span>,%rsi</span><br><span class="line">  <span class="number">0x0000000114353968</span>: movabs $<span class="number">0x10db6e000</span>,%rax</span><br><span class="line">  <span class="number">0x0000000114353972</span>: movb   $<span class="number">0x0</span>,(%rsi,%rax,<span class="number">1</span>)</span><br><span class="line">  <span class="number">0x0000000114353976</span>: lock addl $<span class="number">0x0</span>,(%rsp)     ;*putstatic instance</span><br><span class="line">                                                ; - main.Singleton::getInstance@<span class="number">24</span> (line <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>虽然对于汇编指令了解不多，但还是能从两个对比中看出差异所在。<br>很明显，在<code>movb   $0x0,(%rsi,%rax,1)</code> 之后，加了volatile修饰的汇编代码后面多了一条汇编指令<code>lock addl $0x0,(%rsp)</code>，这个操作相当于一个内存屏障，指令重排时不能把后面的指令重排序到内存屏障之前的位置，当只有一个CPU访问内存时，并不需要内存屏障，当如果有两个或多个CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。<code>lock addl $0x0,(%rsp)</code> 表示把rsp的寄存器的值加0，这显然是一个空操作，关键在于lock前缀。<br><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/L6wWZt.png" alt="image"><br>查询IA32手册，lock前缀会强制执行原子操作，它的作用是是的本CPU的Cache写入了内存，该写入动作会引起别的CPU无效化其Cache。所有通过这样一个空操作，可让前面volatile变量的便是对其他CPU可见。</p><p>那为什么说它能禁止指令重排呢？从硬件架构上讲，指令重排序是指CPU采用了运行将多条指令不按程序规定的顺序分开发送给各相应的点了单元处理，但并不是指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。<code>lock addl $0x0,(%rsp)</code> 指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了” 指令重排序无法越过内存屏障”的效果。</p><blockquote><p>总结来说，内存屏障有两个作用：<br>先于这个内存屏障的指令必须先执行， 后于这个内存屏障的指令必须后执行。<br>如果你的字段是volatile，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据。在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存。</p></blockquote><p>关于volatile关键字的介绍就到这里了，感谢，如果觉得还可以请帮忙点个赞，有问题欢迎留言讨论。</p><p><a href="https://github.com/JasonGaoH/KnowledgeSummary/blob/master/Docs/MultiThread/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90volatile%E5%85%B3%E9%94%AE%E5%AD%97.md" target="_blank" rel="noopener">原文链接</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[深入理解Java虚拟机]<br>[Java高并发编程详解]</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章已同步发表于微信公众号JasonGaoH，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNTE2OTAzMQ==&amp;amp;mid=2247483805&amp;amp;idx=1&amp;amp;sn=a6240f582ec81d047a59f206f8d5ba54&amp;amp;chksm=fa237975cd54f063470a8eb7d68774c474ddab37cf88ff16ac873b47f0ac1b514b8be8254344&amp;amp;token=1938879438&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入解析volatile关键字&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;volatile关键字&lt;/code&gt;和&lt;code&gt;synchronized关键字&lt;/code&gt;一样，在Java多线程开发中，是一道必须要跨越的槛。之前有篇文章已经分析过&lt;code&gt;synchronized关键字&lt;/code&gt;的原理，&lt;a href=&quot;https://blog.csdn.net/H_Gao/article/details/98593198&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;synchronized关键字的原理&lt;/a&gt;，这一次，我们来一步一步分析下&lt;code&gt;volatile关键字&lt;/code&gt;的工作原理。&lt;/p&gt;</summary>
    
    
    
    <category term="多线程" scheme="JasonGaoH.github.io/categories/多线程/"/>
    
    
    <category term="volatile" scheme="JasonGaoH.github.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字的原理</title>
    <link href="JasonGaoH.github.io/2020/05/21/The-principle-of-the%20-synchronized-keyword/"/>
    <id>JasonGaoH.github.io/2020/05/21/The-principle-of-the%20-synchronized-keyword/</id>
    <published>2020-05-21T01:15:50.000Z</published>
    <updated>2023-08-08T11:19:27.079Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章已同步发表于微信公众号JasonGaoH，<a href="https://mp.weixin.qq.com/s?__biz=MzUyNTE2OTAzMQ==&amp;mid=2247483807&amp;idx=1&amp;sn=3bdf01201a329fe98a98c045f5387e1b&amp;chksm=fa237977cd54f061e46fee3727e51208c01931ef704a83526d0fe5e5a15eab386376927888ae&amp;token=1938879438&amp;lang=zh_CN#rd" target="_blank" rel="noopener">synchronized关键字的原理</a></p></blockquote><h3 id="什么是synchronized"><a href="#什么是synchronized" class="headerlink" title="什么是synchronized"></a>什么是synchronized</h3><p>JDK官网对synchronized关键字有个比较权威的解释。</p><p>Synchronized keyword enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visible to more than one thread, all reads or writes to that object’s variables ard done through synchronized methods.</p> <a id="more"></a><p>上述解释的意思是：synchronized关键字可以实现一个简单的策略来防止线程干扰和内存一致性错误，如果一个对象对多个线程是可见的，那么对该对象的所有读或者写都将通过同步的方式来进行，具体表现如下：</p><ul><li>synchronized关键字提供了一种锁的机制，能够确保共享变量的互斥访问，从而防止数据不一致的问题出现。</li><li>synchronized关键字包括monitor enter和monitor exit两个JVM指令，它能够保证在任何时候任何线程执行到monitor enter成功之前都必须从主内存中获取数据，而不是缓存中，在monitor exit运行成功之后，共享变量被更新后的值必须刷入主内存。</li><li>synchronized的执行严格遵守java happens-before 规则，一个monitor exit指令之前必定要有一个monitor enter。</li></ul><h3 id="synchronized关键字的用法"><a href="#synchronized关键字的用法" class="headerlink" title="synchronized关键字的用法"></a>synchronized关键字的用法</h3><p>synchronized可以用于对代码块或方法进行修饰，而不能够用于对class以及变量进行修饰。</p><ul><li>同步方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void sync() &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同步方法块</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final Object lock = new Object();</span><br><span class="line">public void sync() &#123;</span><br><span class="line">    synchronized(lock) &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于同步代码块和同步方法的区别之前写过一个关于这个对比，具体可以看这篇文章。<br><a href="https://blog.csdn.net/h_gao/article/details/52266950" target="_blank" rel="noopener">java中的synchronized（同步代码块和同步方法的区别）</a></p><h3 id="深入分析Synchronized关键字"><a href="#深入分析Synchronized关键字" class="headerlink" title="深入分析Synchronized关键字"></a>深入分析Synchronized关键字</h3><h4 id="线程堆栈分析"><a href="#线程堆栈分析" class="headerlink" title="线程堆栈分析"></a>线程堆栈分析</h4><p>synchronized关键字提供了一种互斥机制，也就是说在同一时刻，只能有一个线程访问同步资源。</p><p>看下面这段程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class TestSync &#123;</span><br><span class="line"></span><br><span class="line">private final static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">public void accessResource() &#123;</span><br><span class="line">synchronized(lock) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.MINUTES.sleep(10);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">final TestSync sync = new TestSync();</span><br><span class="line">for(int i =0;i&lt;5;i++) &#123;</span><br><span class="line">new Thread()&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">sync.accessResource();</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码定义一个方法accessResource，并且使用synchronized来对代码进行同步，同时定义了5个线程调用accessResource方法，由于synchronized的互斥性，只能有一个线程获得lock的monitor锁，其他线程只能进入阻塞状态，等待获取lock的monitor锁。</p><p>针对这个monitor锁我们如何从线程堆栈信息来看呢？</p><p>其实，jstack命令在Java中可以用来打印进程的线程堆栈信息。</p><p>我们来运行这个Java程序，在终端通过top命令查看运行起来的Java程序的进程id，然后执行jstack ‘pid’。</p><p>我们来看下打印出来的信息：<br><img src="../img/jstack_print_info.png" alt></p><p>通过截图可以看到Thread-0持有monitor<0x00000007955f2130>的锁并且处于休眠状态中，而其他几个线程则是处于BLOCKED状态中，它们是在等待着获取monitor<0x00000007955f2130>的锁。</0x00000007955f2130></0x00000007955f2130></p><h4 id="JVM指令分析"><a href="#JVM指令分析" class="headerlink" title="JVM指令分析"></a>JVM指令分析</h4><p>从JVM指令角度再来分析synchronized关键字。</p><p>我们可以使用javap这个命令来对上面这个TestSync类生成的class字节码进行反编译，得到下面的JVM指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;TestSync.java&quot;</span><br><span class="line">public class main.TestSync &#123;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #3                  // class java/lang/Object</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: putstatic     #13                 // Field lock:Ljava/lang/Object;</span><br><span class="line">      10: return</span><br><span class="line"></span><br><span class="line">  public main.TestSync();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public void accessResource();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #13                 // Field lock:Ljava/lang/Object;</span><br><span class="line">       3: dup</span><br><span class="line">       4: astore_1</span><br><span class="line">       5: monitorenter</span><br><span class="line">       6: getstatic     #20                 // Field java/util/concurrent/TimeUnit.MINUTES:Ljava/util/concurrent/TimeUnit;</span><br><span class="line">       9: ldc2_w        #26                 // long 10l</span><br><span class="line">      12: invokevirtual #28                 // Method java/util/concurrent/TimeUnit.sleep:(J)V</span><br><span class="line">      15: goto          23</span><br><span class="line">      18: astore_2</span><br><span class="line">      19: aload_2</span><br><span class="line">      20: invokevirtual #32                 // Method java/lang/InterruptedException.printStackTrace:()V</span><br><span class="line">      23: aload_1</span><br><span class="line">      24: monitorexit</span><br><span class="line">      25: goto          31</span><br><span class="line">      28: aload_1</span><br><span class="line">      29: monitorexit</span><br><span class="line">      30: athrow</span><br><span class="line">      31: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           6    15    18   Class java/lang/InterruptedException</span><br><span class="line">           6    25    28   any</span><br><span class="line">          28    30    28   any</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #1                  // class main/TestSync</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #44                 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: iconst_0</span><br><span class="line">       9: istore_2</span><br><span class="line">      10: goto          27</span><br><span class="line">      13: new           #45                 // class main/TestSync$1</span><br><span class="line">      16: dup</span><br><span class="line">      17: aload_1</span><br><span class="line">      18: invokespecial #47                 // Method main/TestSync$1.&quot;&lt;init&gt;&quot;:(Lmain/TestSync;)V</span><br><span class="line">      21: invokevirtual #50                 // Method main/TestSync$1.start:()V</span><br><span class="line">      24: iinc          2, 1</span><br><span class="line">      27: iload_2</span><br><span class="line">      28: iconst_5</span><br><span class="line">      29: if_icmplt     13</span><br><span class="line">      32: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的指令中可以看到，在accessResource()方法中，先后出现了一个monitor enter和两个monitor exit。</p><p>我们主要选取accessResource()这部分代码块来重点分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void accessResource();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #13                 //①获取lock</span><br><span class="line">       3: dup</span><br><span class="line">       4: astore_1</span><br><span class="line">       5: monitorenter                      //②执行monitorenter JVM指令</span><br><span class="line">       6: getstatic     #20                 // Field java/util/concurrent/TimeUnit.MINUTES:Ljava/util/concurrent/TimeUnit;</span><br><span class="line">       9: ldc2_w        #26                 // long 10l</span><br><span class="line">      12: invokevirtual #28                 // Method java/util/concurrent/TimeUnit.sleep:(J)V</span><br><span class="line">      15: goto          23                  //③跳转到23行</span><br><span class="line">      18: astore_2</span><br><span class="line">      19: aload_2</span><br><span class="line">      20: invokevirtual #32                 // Method java/lang/InterruptedException.printStackTrace:()V</span><br><span class="line">      23: aload_1                           //④</span><br><span class="line">      24: monitorexit                       //⑤ 执行monitor exit JVM指令</span><br><span class="line">      25: goto          31</span><br><span class="line">      28: aload_1</span><br><span class="line">      29: monitorexit</span><br><span class="line">      30: athrow</span><br><span class="line">      31: return</span><br></pre></td></tr></table></figure></p><p>首先①获取到lock引用，然后执行②monitorenter JVM指令，休眠结束后goto至③monitorexit的位置<br>（astore_n表示存储引用到本地变量表；aload_n表示从本地变量表加载应用；getstatic表示从class中获取静态属性）</p><p>monitorenter</p><blockquote><p>每一个对象都与一个monitor相关联，一个monitor的lock的锁只能被一个线程在同一时间获得，在一个线程尝试获得与对象关联的monitor的所有权时会发生如下的几件事情。</p></blockquote><ul><li>如果monitor的计数器为0，则意味着该monitor的lock还没有被获得，，某个线程获得之后将立即对该计数器加一，从此该线程就是这个monitor的所有者了。</li><li>如果一个已经拥有该线程所有权的线程重入，则会导致monitor的计数器再次累加。</li><li>如果monitor已经被其他线程所拥有，则其他线程尝试获取该monitor所有权时，会被陷入阻塞状态直到monitor变为0，才能再次尝试获取对monitor的所有权。</li></ul><p>monitorexit</p><p>释放对monitor的所有权，想要释放某个对象关联的monitor所有权的前提是，你曾经拥有了所有权。释放monitor所有权的过程比较简单，就是将monitor的计数器减一，如果计数器的结果为0，则意味着该线程不在拥有对该monitor的所有权，通俗地讲就是解锁。</p><h4 id="synchronized的锁优化"><a href="#synchronized的锁优化" class="headerlink" title="synchronized的锁优化"></a>synchronized的锁优化</h4><p>在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的，首先，synchronized同步块对于同一条线程是可重入的，不会出现自己锁死自己的问题。其次，同步块在已进入的线程执行完以前，会阻塞后面其他线程的进入。</p><p>Java的线程是映射到操作系统线程上的，要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态切到核心态，因此状态转换需要耗费很多的处理器时间，对于简单的同步块（如被synchronized修饰的getter或setter方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。所以synchronized是Java语言中的一个重量级的操作。</p><p>其实大多数时候，共享数据的锁定状态一般只会持续很短的一段时间，为了这段时间去挂起和恢复线程其实并不值得。</p><p>如果物理机上有多个处理器，可以让多个线程同时执行的话。我们就可以让后面来的线程“稍微等一下”，但是并不放弃处理器的执行时间，看看持有锁的线程会不会很快释放锁。这个“稍微等一下”的过程就是自旋。</p><p>自旋锁在JDK 1.4中已经引入，在JDK 1.6中默认开启。只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快，因为上面刚说到，线程的状态切换会耗费很多CPU时间。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段，适合使用自旋锁。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章已同步发表于微信公众号JasonGaoH，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNTE2OTAzMQ==&amp;amp;mid=2247483807&amp;amp;idx=1&amp;amp;sn=3bdf01201a329fe98a98c045f5387e1b&amp;amp;chksm=fa237977cd54f061e46fee3727e51208c01931ef704a83526d0fe5e5a15eab386376927888ae&amp;amp;token=1938879438&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;synchronized关键字的原理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是synchronized&quot;&gt;&lt;a href=&quot;#什么是synchronized&quot; class=&quot;headerlink&quot; title=&quot;什么是synchronized&quot;&gt;&lt;/a&gt;什么是synchronized&lt;/h3&gt;&lt;p&gt;JDK官网对synchronized关键字有个比较权威的解释。&lt;/p&gt;
&lt;p&gt;Synchronized keyword enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visible to more than one thread, all reads or writes to that object’s variables ard done through synchronized methods.&lt;/p&gt;</summary>
    
    
    
    <category term="源码分析" scheme="JasonGaoH.github.io/categories/源码分析/"/>
    
    
    <category term="synchronized" scheme="JasonGaoH.github.io/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>关于HashMap你需要知道的一些细节</title>
    <link href="JasonGaoH.github.io/2020/05/21/some-knowledge-about-hashmap/"/>
    <id>JasonGaoH.github.io/2020/05/21/some-knowledge-about-hashmap/</id>
    <published>2020-05-21T01:14:14.000Z</published>
    <updated>2023-08-08T11:19:27.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章已同步发表于微信公众号JasonGaoH，<a href="https://mp.weixin.qq.com/s?__biz=MzUyNTE2OTAzMQ==&amp;mid=2247483757&amp;idx=1&amp;sn=f8cf2e5f82b6cf0e64aab6febf7e7584&amp;chksm=fa237985cd54f0937f9c3c2d3df40b1136602b00d253d2104452ef72319bae6ca7ffcc4f1183&amp;token=1938879438&amp;lang=zh_CN#rd" target="_blank" rel="noopener">关于HashMap你需要知道的一些细节</a></p></blockquote><p>在官方文档中的描述：</p><blockquote><p>Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p></blockquote><a id="more"></a><blockquote><p>基于Map接口的哈希表的实现。此实现提供所有可选的映射操作，并允许空值和空键。（HashMap类大致等同于HashTable，只是它不同步并且允许空值。）这个类不保证映射的顺序；特别是，它不保证顺序会随着时间的推移而保持不变。</p></blockquote><h3 id="两个重要的参数"><a href="#两个重要的参数" class="headerlink" title="两个重要的参数"></a>两个重要的参数</h3><p>在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor)</p><blockquote><ul><li>Initial capacity The capacity is the number of buckets in the hash table, The initial capacity is simply the capacity at the time the hash table is created.</li><li>Load factor The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased.</li></ul></blockquote><p>简单的说，Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。当bucket填充的数目（即hashmap中元素的个数）大于capacity*load factor时就需要调整buckets的数目为当前的2倍。</p><p>首先，我们来一起看看 HashMap 内部的结构，它可以看作是数组(Node[] table)和链表结 合组成的复合结构，数组被分为一个个桶(bucket)，通过哈希值决定了键值对在这个数组的寻址;哈希值相同的键值对，则以链表形式存储，你可以参考下面的示意图。这里需要注意的是，如果链表大小超过阈值(TREEIFY_THRESHOLD, 8)，图中的链表就会被改造为树形结构。</p><p><img src="../img/Buckets.jpg" alt></p><h3 id="put函数的实现"><a href="#put函数的实现" class="headerlink" title="put函数的实现"></a>put函数的实现</h3><p>接着来看 put 方法实现:</p><p>put函数大致的思路为：</p><ol><li>对key的hashCode()做hash，然后再计算index;</li><li>如果没碰撞直接放到bucket里；</li><li>如果碰撞了，以链表的形式存在buckets后；</li><li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li><li>如果节点已经存在就替换old value(保证key的唯一性)</li><li>如果bucket满了(超过load factor*current capacity)，就要resize。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算index，并对null做处理</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 节点存在</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 该链为树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过load factor*current capacity，resize</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 putVal 方法最初的几行，我们就可以发现几个有意思的地方:</p><ul><li>如果表格是 null，resize 方法会负责初始化它，这从 tab = resize() 可以看出。</li><li>resize 方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容 (resize)。</li><li>在放置新的键值对的过程中，如果发生下面条件，就会发生扩容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">resize();</span><br></pre></td></tr></table></figure><ul><li>具体键值对在哈希表中的位置(数组 index)取决于下面的位运算:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>仔细观察哈希值的源头，我们会发现，它并不是 key 本身的 hashCode，而是来自于 HashMap 内部的另外一个 hash 方法。注意，为什么这里需要将高位数据移位到低位进行异或运算呢?这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽 略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object kye)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt;<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我前面提到的链表结构(这里叫 bin)，会在达到一定门限值时，发生树化，我稍后会分析 为什么 HashMap 需要对 bin 进行处理。</li></ul><p>可以看到，putVal 方法本身逻辑非常集中，从初始化、扩容到树化，全部都和它有关。</p><p>进一步分析一下身兼多职的 resize 方法，很多朋友都反馈经常被面试官追问它的源码设计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACIY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPAITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double there</span></span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zero initial threshold signifies using defaultsfults newCap = DEFAULT_INITIAL_CAPAITY;</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr ==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFator;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?(<span class="keyword">int</span>)ft : Intege</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = neThr;</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newap]; table = n;</span><br><span class="line">    <span class="comment">// 移动到新的数组结构 e 数组结构 &#125;</span></span><br></pre></td></tr></table></figure><p>依据 resize 源码，不考虑极端情况(容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值 为 1&lt;&lt;30，也就是 2 的 30 次方)，我们可以归纳为:</p><ul><li>门限值等于(负载因子)x(容量)，如果构建 HashMap 的时候没有指定它们，那么就是依 据相应的默认常量值。</li><li>门限通常是以倍数进行调整 (newThr = oldThr &lt;&lt; 1)，我前面提到，根据 putVal 中的逻 辑，当元素个数超过门限大小时，则调整 Map 大小。</li><li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li></ul><h3 id="容量、负载因子"><a href="#容量、负载因子" class="headerlink" title="容量、负载因子"></a>容量、负载因子</h3><p>前面我们快速梳理了一下 HashMap 从创建到放入键值对的相关逻辑，现在思考一下，为什么 我们需要在乎容量和负载因子呢?</p><p>这是因为容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严<br>重影响操作的性能。极端情况下，假设只有一个桶，那么它就退化成了链表，完全不能提供所谓<br>常数时间存储的性能。<br>既然容量和负载因子这么重要，我们在实践中应该如何选择呢?</p><p>如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。具体数值 我们可以根据扩容发生的条件来做简单预估，根据前面的代码分析，我们知道它需要符合计算条件:</p><p>负载因子 * 容量 &gt; 元素数量</p><p>所以，预先设置的容量需要满足，大于“预估元素数量 / 负载因子”，同时它是 2 的幂数，结论已经非常清晰了。</p><p>而对于负载因子，我建议:</p><ul><li><p>如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的。</p></li><li><p>如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能。</p></li><li>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加<br>频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li></ul><h3 id="树化改造"><a href="#树化改造" class="headerlink" title="树化改造"></a>树化改造</h3><p> 我们前面提到了树化改造，对应逻辑主要在 putVal 和 treeifyBin 中。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 树化改造逻辑 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是精简过的 treeifyBin 示意，综合这两个方法，树化改造的逻辑就非常清晰了，可以理解为，当 bin 的数量大于 TREEIFY_THRESHOLD 时:</p><ul><li>如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容。</li><li>如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。 </li></ul><p>那么，为什么 HashMap 要树化呢?</p><p>本质上这是个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶<br>里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能。</p><h3 id="hash函数的实现"><a href="#hash函数的实现" class="headerlink" title="hash函数的实现"></a>hash函数的实现</h3><p>接着我们着重来看hash函数的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object kye)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt;<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码实际上称为“扰动函数”，Java 8的代码相对Java 7是做过简化的，但原理是不变的。</p><p>我们都知道上面代码里的key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值。</p><p>理论上hashCode是一个int值，这个int值范围在-2147483648和2147483648之间，如果直接拿这个hashCode作为HashMap中数组的下标来访问的话，正常情况下是不会出现hash碰撞的。<br>但是这样的话会导致这个HashMap的数组长度比较长，长度大概为40亿，内存肯定是放不下的，所以这个时候需要把这个hashCode对数组长度取余，用得到的余数来访问数组下标。</p><p>所以我们看到HashMap中get方法和put方法都有下面这样的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab[(n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure></p><p>(n-1)&amp;hash实际上相当于hash%n取余数，但&amp;计算速度更快。</p><p>这里我们举个例子：<br>以初始长度为16为例，16-1=15。2进制表示是00000000 00000000 00001111。<br>我们把15和某hashCode值做“与”操作如下，结果就是截取了最低的四位值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">10100101</span> <span class="number">11000100</span> <span class="number">00100101</span></span><br><span class="line">&amp;<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span>    <span class="comment">//高位全部归零，只保留末四位</span></span><br></pre></td></tr></table></figure></p><p>这样问题就来了，我们如果只是取低位的情况下，碰撞就会很严重。</p><p>这时候“扰动函数”的价值就体现出来了，我们来看下面这张图片：<br><img src="../img/hashmap_hash.jpg" alt></p><p>右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p><p>这样大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p><p>以上就是关于HashMap中hash函数设计的原理。</p><h3 id="resize的实现原理"><a href="#resize的实现原理" class="headerlink" title="resize的实现原理"></a>resize的实现原理</h3><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的：</p><blockquote><p>Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</p></blockquote><p>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p><p><img src="../img/hashmap_resize.jpg" alt></p><p>我们来上面这张图，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希值(也就是根据key1算出来的hashcode值)与高位与运算的结果。</p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><img src="../img/hashmap_resize2.jpg" alt></p><p> 这样我们resize的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap。</p><p> 这个就是resize设计巧妙的地方，在扩容的时候，我们不需要重新去计算hash的值，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p> <a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Java HashMap工作原理及实现</a></p><p><a href="https://www.zhihu.com/question/20733617" target="_blank" rel="noopener">HashMap 的 hash 方法原理</a></p><p><a href="https://blog.csdn.net/u012961566/article/details/72963157" target="_blank" rel="noopener">HashMap的扩容机制</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章已同步发表于微信公众号JasonGaoH，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNTE2OTAzMQ==&amp;amp;mid=2247483757&amp;amp;idx=1&amp;amp;sn=f8cf2e5f82b6cf0e64aab6febf7e7584&amp;amp;chksm=fa237985cd54f0937f9c3c2d3df40b1136602b00d253d2104452ef72319bae6ca7ffcc4f1183&amp;amp;token=1938879438&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于HashMap你需要知道的一些细节&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在官方文档中的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="源码分析" scheme="JasonGaoH.github.io/categories/源码分析/"/>
    
    
    <category term="HashMap" scheme="JasonGaoH.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap是如何保证线程安全的</title>
    <link href="JasonGaoH.github.io/2020/05/21/how-does-ConcurrentHashMap-work/"/>
    <id>JasonGaoH.github.io/2020/05/21/how-does-ConcurrentHashMap-work/</id>
    <published>2020-05-21T01:11:55.000Z</published>
    <updated>2023-08-08T11:19:27.079Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章已同步发表于微信公众号JasonGaoH，<a href="https://mp.weixin.qq.com/s?__biz=MzUyNTE2OTAzMQ==&amp;mid=2247483797&amp;idx=1&amp;sn=cb28703e574bbf5df4563d3aef65be01&amp;chksm=fa23797dcd54f06b34b405d4eef74a14df420fcc16b6b1e42fb16060972ea20c8695ee8c5f29&amp;token=1938879438&amp;lang=zh_CN#rd" target="_blank" rel="noopener">ConcurrentHashMap是如何保证线程安全的</a></p></blockquote><p>之前分析过HashMap的一些实现细节，<a href="https://blog.csdn.net/H_Gao/article/details/90746413" target="_blank" rel="noopener">关于HashMap你需要知道的一些细节</a>, 今天我们从源码角度来看看ConcurrentHashMap是如何实现线程安全的，其实网上这类文章分析特别多，秉着”纸上得来终觉浅，绝知此事要躬行“的原则，我们尝试自己去分析下，希望这样对于ConcurrentHashMap有一个更深刻的理解。</p> <a id="more"></a><h3 id="为什么说HashMap线程不安全，而ConcurrentHashMap就线程安全"><a href="#为什么说HashMap线程不安全，而ConcurrentHashMap就线程安全" class="headerlink" title="为什么说HashMap线程不安全，而ConcurrentHashMap就线程安全"></a>为什么说HashMap线程不安全，而ConcurrentHashMap就线程安全</h3><p>其实ConcurrentHashMap在Android开发中使用的场景并不多，但是ConcurrentHashMap为了支持多线程并发这些优秀的设计却是最值得我们学习的地方，往往”ConcurrentHashMap是如何实现线程安全“这类问题却是面试官比较喜欢问的问题。</p><p>首先，我们尝试用代码模拟下HashMap在多线程场景下会不安全，如果把这个场景替换成ConcurrentHashMap会不会有问题。</p><p>因为不同于其他的线程同步问题，想模拟出一种场景来表明HashMap是线程不安全的稍微有点麻烦，可能是hash散列有关，在数据量较小的情况下，计算出来的hashCode是不太容易产生碰撞的，网上很多文章都是尝试从源码角度来分析HashMap可能会导致的线程安全问题。</p><p>我们来看下下面这段代码,我们构造10个线程，每个线程分别往map中put 1000个数据，为了保证每个数据的key不一样，我们将i+ 线程名字来作为map 的key，这样，如果所有的线程都累加完的话，我们预期的map的size应该是10 * 1000 = 10000。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;String, String&gt;();</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">MyThread testThread = <span class="keyword">new</span> MyThread(map, <span class="string">"线程名字："</span> + i);</span><br><span class="line">    testThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//等待所有线程都结束</span></span><br><span class="line"><span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">Thread.yield();</span><br><span class="line"></span><br><span class="line">System.out.println(map.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; map;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Map&lt;String, String&gt; map, String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.map = map;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) &#123;</span><br><span class="line">    map.put(i + name, i + name);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>使用HashMap，程序运行，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9930</span><br></pre></td></tr></table></figure></p><p>那我们如果把这里的HashMap换成ConcurrentHashMap来试试看看效果如何，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000</span><br></pre></td></tr></table></figure><p>我们发现不管运行几次，HashMap的size都是小于10000的，而ConcurrentHashMap的size都是10000。从这个角度也证明了ConcurrentHashMap是线程安全的，而HashMap则是线程不安全的。<br>HashMap在多线程put的时候，当产生hash碰撞的时候，会导致丢失数据，因为要put的两个值hash相同，如果这个对于hash桶的位置个数小于8，那么应该是以链表的形式存储，由于没有做通过，后面put的元素可能会直接覆盖之前那个线程put的数据，这样就导致了数据丢失。</p><p>其实列举上面这个例子只是为了从一个角度来展示下为什么说HashMap线程不安全，而ConcurrentHashMap则是线程安全的，鉴于HashMap线程安全例子比较难列举出来，所有才通过打印size这个角度来模拟了下。</p><p>这篇文章<a href="https://juejin.im/post/5c8910286fb9a049ad77e9a3" target="_blank" rel="noopener">深入解读HashMap线程安全性问题</a>就详细介绍了HashMap可能会出现线程安全问题。<br>文章主要讲了两个可能会出现线程不安全地方，一个是多线程的put可能导致元素的丢失，另一个是put和get并发时，可能导致get为null，但是也仅是在源码层面分析了下，因为这中场景想要完全用代码展示出来是稍微有点麻烦的。</p><p>接下来我们来看看ConcurrentHashMap是如何做到线程安全的。</p><h3 id="JDK8的ConcurrentHashMap文档提炼"><a href="#JDK8的ConcurrentHashMap文档提炼" class="headerlink" title="JDK8的ConcurrentHashMap文档提炼"></a>JDK8的ConcurrentHashMap文档提炼</h3><ul><li>ConcurrentHashMap支持检索的完全并发和更新的高预期并发性,这里的说法很有意思检索支持完全并发，更新则支持高预期并发性，因为它的检索操作是没有加锁的，实际上检索也没有必要加锁。</li><li>实际上ConcurrentHashMap和Hashtable在不考虑实现细节来说，这两者完全是可以互相操作的,Hashtable在get，put，remove等这些方法中全部加入了synchronized，这样的问题是能够实现线程安全，但是缺点是性能太差，几乎所有的操作都加锁的，但是ConcurrentHashMap的检测操作却是没有加锁的。</li><li>ConcurrentHashMap检索操作(包括get)通常不会阻塞，因此可能与更新操作(包括put和remove)重叠。</li><li><p>ConcurrentHashMap跟Hashtable类似但不同于HashMap，它不可以存放空值，key和value都不可以为null。</p><p>印象中一直以为ConcurrentHashMap是基于Segment分段锁来实现的，之前没仔细看过源码，一直有这么个错误的认识。ConcurrentHashMap是基于Segment分段锁来实现的，这句话也不能说不对，加个前提条件就是正确的了，ConcurrentHashMap从JDK1.5开始随java.util.concurrent包一起引入JDK中，在JDK8以前，ConcurrentHashMap都是基于Segment分段锁来实现的，在JDK8以后，就换成synchronized和CAS这套实现机制了。</p></li></ul><p>JDK1.8中的ConcurrentHashMap中仍然存在Segment这个类，而这个类的声明则是为了兼容之前的版本序列化而存在的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Stripped-down version of helper class used in previous version,</span></span><br><span class="line"><span class="comment">  * declared for the sake of serialization compatibility.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">     Segment(<span class="keyword">float</span> lf) &#123; <span class="keyword">this</span>.loadFactor = lf; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>JDK1.8中的ConcurrentHashMap不再使用Segment分段锁，而是以table数组的头结点作为synchronized的锁。和JDK1.8中的HashMap类似，对于hashCode相同的时候，在Node节点的数量少于8个时，这时的Node存储结构是链表形式，时间复杂度为O(N)，当Node节点的个数超过8个时，则会转换为红黑树，此时访问的时间复杂度为O(long(N))。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment">    * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></p><p>数据结构图如下所示：<br><img src="https://raw.githubusercontent.com/JasonGaoH/KnowledgeSummary/master/Docs/img/concurrenthashmap.png" alt="在这里插入图片描述"></p><p>其实ConcurrentHashMap保证线程安全主要有三个地方。</p><blockquote><ul><li>一、使用volatile保证当Node中的值变化时对于其他线程是可见的</li><li>二、使用table数组的头结点作为synchronized的锁来保证写操作的安全</li><li>三、当头结点为null时，使用CAS操作来保证数据能正确的写入。</li></ul></blockquote><h3 id="使用volatile"><a href="#使用volatile" class="headerlink" title="使用volatile"></a>使用volatile</h3><p>可以看到，Node中的val和next都被volatile关键字修饰。</p><blockquote><p>volatile的happens-before规则：对一个volatile变量的写一定可见（happens-before)于随后对它的读。</p></blockquote><p>也就是说，我们改动val的值或者next的值对于其他线程是可见的，因为volatile关键字，会在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>另外，ConcurrentHashMap提供类似tabAt来读取Table数组中的元素，这里是以volatile读的方式读取table数组中的元素，主要通过Unsafe这个类来实现的，保证其他线程改变了这个数组中的值的情况下，在当前线程get的时候能拿到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>而与之对应的，是setTabAt,这里是以volatile写的方式往数组写入元素，这样能保证修改后能对其他线程可见。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">       U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>我们来看下ConcurrentHashMap的putVal方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">      <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">          Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">          <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">              tab = initTable();</span><br><span class="line">          <span class="comment">//当头结点为null,则通过casTabAt方式写入</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                           <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                  <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//正在扩容</span></span><br><span class="line">              tab = helpTransfer(tab, f);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              V oldVal = <span class="keyword">null</span>;</span><br><span class="line">              <span class="comment">//头结点不为null，使用synchronized加锁</span></span><br><span class="line">              <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                          <span class="comment">//此时hash桶是链表结构</span></span><br><span class="line">                          binCount = <span class="number">1</span>;</span><br><span class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                              K ek;</span><br><span class="line">                              <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                  ((ek = e.key) == key ||</span><br><span class="line">                                   (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                  oldVal = e.val;</span><br><span class="line">                                  <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                      e.val = value;</span><br><span class="line">                                  <span class="keyword">break</span>;</span><br><span class="line">                              &#125;</span><br><span class="line">                              Node&lt;K,V&gt; pred = e;</span><br><span class="line">                              <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                  pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                            value, <span class="keyword">null</span>);</span><br><span class="line">                                  <span class="keyword">break</span>;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                          <span class="comment">//此时是红黑树</span></span><br><span class="line">                          Node&lt;K,V&gt; p;</span><br><span class="line">                          binCount = <span class="number">2</span>;</span><br><span class="line">                          <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                         value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              oldVal = p.val;</span><br><span class="line">                              <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                  p.val = value;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive update"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//当链表结构大于等于8，则将链表转换为红黑树</span></span><br><span class="line">                  <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                      treeifyBin(tab, i);</span><br><span class="line">                  <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> oldVal;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>在putVal方法重要的地方都加了注释，可以帮助理解，现在我们一步一步来看putVal方法。</p><h3 id="使用CAS"><a href="#使用CAS" class="headerlink" title="使用CAS"></a>使用CAS</h3><p>当有一个新的值需要put到ConcurrentHashMap中时，首先会遍历ConcurrentHashMap的table数组，然后根据key的hashCode来定位到需要将这个value放到数组的哪个位置。</p><p><code>tabAt(tab, i = (n - 1) &amp; hash))</code>就是定位到这个数组的位置，如果当前这个位置的Node为null，则通过CAS方式的方法写入。所谓的CAS，即即compareAndSwap，执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。</p><p>这里就是调用casTabAt方法来实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>casTabAt同样是通过调用Unsafe类来实现的，调用Unsafe的compareAndSwapObject来实现，其实如果仔细去追踪这条线路，会发现其实最终调用的是cmpxchg这个CPU指令来实现的，这是一个CPU的原子指令，能保证数据的一致性问题。</p><h3 id="使用synchronized"><a href="#使用synchronized" class="headerlink" title="使用synchronized"></a>使用synchronized</h3><p>当头结点不为null时，则使用该头结点加锁，这样就能多线程去put hashCode相同的时候不会出现数据丢失的问题。synchronized是互斥锁，有且只有一个线程能够拿到这个锁，从而保证了put操作是线程安全的。</p><p>下面是ConcurrentHashMap的put操作的示意图，图片来自于<a href="https://www.jianshu.com/p/5bc70d9e5410" target="_blank" rel="noopener">ConcurrentHashMap源码分析(JDK8)get/put/remove方法分析</a>。<br><img src="https://raw.githubusercontent.com/JasonGaoH/KnowledgeSummary/master/Docs/img/concurrenthashmap_put.webp" alt="在这里插入图片描述"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.jasongj.com/java/concurrenthashmap/" target="_blank" rel="noopener">从ConcurrentHashMap的演进看Java多线程核心技术</a></p><p><a href="https://www.jianshu.com/p/5bc70d9e5410" target="_blank" rel="noopener">ConcurrentHashMap源码分析(JDK8)get/put/remove方法分析</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章已同步发表于微信公众号JasonGaoH，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNTE2OTAzMQ==&amp;amp;mid=2247483797&amp;amp;idx=1&amp;amp;sn=cb28703e574bbf5df4563d3aef65be01&amp;amp;chksm=fa23797dcd54f06b34b405d4eef74a14df420fcc16b6b1e42fb16060972ea20c8695ee8c5f29&amp;amp;token=1938879438&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ConcurrentHashMap是如何保证线程安全的&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前分析过HashMap的一些实现细节，&lt;a href=&quot;https://blog.csdn.net/H_Gao/article/details/90746413&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于HashMap你需要知道的一些细节&lt;/a&gt;, 今天我们从源码角度来看看ConcurrentHashMap是如何实现线程安全的，其实网上这类文章分析特别多，秉着”纸上得来终觉浅，绝知此事要躬行“的原则，我们尝试自己去分析下，希望这样对于ConcurrentHashMap有一个更深刻的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="多线程" scheme="JasonGaoH.github.io/categories/多线程/"/>
    
    
    <category term="ConcurrentHashMap" scheme="JasonGaoH.github.io/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>我画了近百张图来理解红黑树</title>
    <link href="JasonGaoH.github.io/2020/05/21/understand-treemap-by-using-imags/"/>
    <id>JasonGaoH.github.io/2020/05/21/understand-treemap-by-using-imags/</id>
    <published>2020-05-21T01:09:56.000Z</published>
    <updated>2023-08-08T11:19:27.081Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章已同步发表于微信公众号JasonGaoH，<a href="https://mp.weixin.qq.com/s?__biz=MzUyNTE2OTAzMQ==&amp;mid=2247483855&amp;idx=1&amp;sn=673e581b766d6ec80ec6151e5d732a32&amp;chksm=fa237927cd54f031d5df25b8783551d889200ddab408d1cc5c12533b9d5ab85f99ba78d07b06&amp;token=1938879438&amp;lang=zh_CN#rd" target="_blank" rel="noopener">我画了近百张图来理解红黑树</a>,文章略有修改。</p></blockquote><p>之前在公司组内分享了红黑树的工作原理，今天把它整理下发出来，希望能对大家有所帮助，对自己也算是一个知识点的总结。</p><p>这篇文章算是我写博客写公众号以来画图最多的一篇文章了，没有之一，我希望尽可能多地用图片来形象地描述红黑树的各种操作的前后变换原理，帮助大家来理解红黑树的工作原理，下面，多图预警开始了。<br> <a id="more"></a></p><p>在讲红黑树之前，我们首先来了解下下面几个概念：二叉树，排序二叉树以及平衡二叉树。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树指的是每个节点最多只能有两个字数的有序树。通常左边的子树称为<code>左子树</code> ，右边的子树称为<code>右子树</code> 。这里说的有序树强调的是二叉树的左子树和右子树的次序不能随意颠倒。</p><p>二叉树简单的示意图如下：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/binary_tree_node.png" alt></p><p>代码定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h2><p>所谓排序二叉树，顾名思义，排序二叉树是有顺序的，它是一种特殊结构的二叉树，我们可以对树中所有节点进行排序和检索。</p><blockquote><p>性质</p><ul><li>若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若她的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>具有递归性，排序二叉树的左子树、右子树也是排序二叉树。</li></ul></blockquote><p>排序二叉树简单示意图：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/binary_search_tree.png" alt="排序二叉树"></p><h3 id="排序二叉树退化成链表"><a href="#排序二叉树退化成链表" class="headerlink" title="排序二叉树退化成链表"></a>排序二叉树退化成链表</h3><p>排序二叉树的左子树上所有节点的值小于根节点的值，右子树上所有节点的值大于根节点的值，当我们插入一组元素正好是有序的时候，这时会让排序二叉树退化成链表。</p><p>正常情况下，排序二叉树是如下图这样的：<br><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_15.png" alt></p><p>但是，当插入的一组元素正好是有序的时候，排序二叉树就变成了下边这样了，就变成了普通的链表结构，如下图所示:<br><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/binary_search_link_tree.png" alt></p><p>正常情况下的排序二叉树检索效率类似于二分查找，二分查找的时间复杂度为 O(log n)，但是如果排序二叉树退化成链表结构，那么检索效率就变成了线性的 O(n) 的，这样相对于 O(log n) 来说，检索效率肯定是要差不少的。</p><blockquote><p>思考，二分查找和正常的排序二叉树的时间复杂度都是 O(log n)，那么为什么是O(log n) ？</p></blockquote><p>关于 O(log n) 的分析下面这篇文章讲解的非常好，感兴趣的可以看下这篇文章 <a href="https://github.com/JasonGaoH/KnowledgeSummary/blob/master/Docs/Algorithm/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AFO(log%20n" target="_blank" rel="noopener">二分查找的时间复杂度</a>.md)，文章是拿二分查找来举例的，二分查找和平衡二叉树的时间复杂度是一样的，理解了二分查找的时间复杂度，再来理解平衡二叉树就不难了，这里就不赘述了。</p><p>继续回到我们的主题上，为了解决排序二叉树在特殊情况下会退化成链表的问题（链表的检索效率是 O(n) 相对正常二叉树来说要差不少），所以有人发明了<code>平衡二叉树</code>和<code>红黑树</code>类似的平衡树。</p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉数又被称为 AVL 树，AVL 树的名字来源于它的发明作者 G.M. Adelson-Velsky 和 E.M. Landis，取自两人名字的首字母。</p><p>官方定义：它或者是一颗空树，或者具有以下性质的排序二叉树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。</p><p>两个条件：</p><ul><li>平衡二叉树必须是排序二叉树，也就是说平衡二叉树他的左子树所有节点的值必须小于根节点的值，它的右子树上所有节点的值必须大于它的根节点的值。</li><li>左子树和右子树的深度之差的绝对值不超过1。</li></ul><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>讲了这么多概念，接下来主角红黑树终于要上场了。</p><blockquote><p>为什么有红黑树？</p></blockquote><p>其实红黑树和上面的平衡二叉树类似，本质上都是为了解决排序二叉树在极端情况下退化成链表导致检索效率大大降低的问题，红黑树最早是由 Rudolf Bayer 于 1972 年发明的。</p><p>红黑树首先肯定是一个排序二叉树，它在每个节点上增加了一个存储位来表示节点的颜色，可以是 RED 或 BLACK 。</p><p>Java 中实现红黑树大概结构图如下所示：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_13.png" alt></p><h3 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h3><ul><li>性质1：每个节点要么是红色，要么是黑色。</li><li>性质2：根节点永远是黑色的。</li><li>性质3：所有的叶子节点都是空节点（即null），并且是黑色的。</li><li>性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点。）</li><li>性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</li></ul><p>针对上面的 5 种性质，我们简单理解下，对于性质 1 和性质 2 ，相当于是对红黑树每个节点的约束，根节点是黑色，其他的节点要么是红色，要么是黑色。</p><p>对于性质 3 中指定红黑树的每个叶子节点都是空节点，而且叶子节点都是黑色，但 Java 实现的红黑树会使用 null 来代表空节点，因此我们在遍历 Java里的红黑树的时候会看不到叶子节点，而看到的是每个叶子节点都是红色的，这一点需要注意。</p><p>对于性质 5，这里我们需要注意的是，这里的描述是从任一节点，从任一节点到它的子树的每个叶子节点黑色节点的数量都是相同的，这个数量被称为这个节点的黑高。</p><p>如果我们从根节点出发到每个叶子节点的路径都包含相同数量的黑色节点，这个黑色节点的数量被称为树的黑色高度。树的黑色高度和节点的黑色高度是不一样的，这里要注意区分。</p><p>其实到这里有人可能会问了，红黑树的性质说了一大堆，那是不是说只要保证红黑树的节点是红黑交替就能保证树是平衡的呢？</p><p>其实不是这样的，我们可以看来看下面这张图：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_14.png" alt></p><p>左边的子树都是黑色节点，但是这个红黑树依然是平衡的，5 条性质它都满足。</p><p>这个树的黑色高度为 3，从根节点到叶子节点的最短路径长度是 2，该路径上全是黑色节点，包括叶子节点，从根节点到叶子节点最长路径为 4，每个黑色节点之间会插入红色节点。</p><p>通过上面的性质 4 和性质 5，其实上保证了没有任何一条路径会比其他路径长出两倍，所以这样的红黑树是平衡的。</p><p>其实这算是一个推论，红黑树在最差情况下，最长的路径都不会比最短的路径长出两倍。其实红黑树并不是真正的平衡二叉树，它只能保证大致是平衡的，因为红黑树的高度不会无限增高，在实际应用用，红黑树的统计性能要高于平衡二叉树，但极端性能略差。</p><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><p>想要彻底理解红黑树，除了上面说到的理解红黑树的性质以外，就是理解红黑树的插入操作了。</p><p>红黑树的插入和普通排序二叉树的插入基本一致，排序二叉树的要求是左子树上的所有节点都要比根节点小，右子树上的所有节点都要比跟节点大，当插入一个新的节点的时候，首先要找到当前要插入的节点适合放在排序二叉树哪个位置，然后插入当前节点即可。红黑树和排序二叉树不同的是，红黑树需要在插入节点调整树的结构来让树保持平衡。</p><p>一般情况下，红黑树中新插入的节点都是红色的，那么，为什么说新加入到红黑树中的节点要是红色的呢？</p><p>这个问题可以这样理解，我们从性质5中知道，当前红黑树中从根节点到每个叶子节点的黑色节点数量是一样的，此时假如新的黑色节点的话，必然破坏规则，但加入红色节点却不一定，除非其父节点就是红色节点，因此加入红色节点，破坏规则的可能性小一些。</p><p>接下来我们重点来讲红黑树插入新节点后是如何保持平衡的。</p><p>给定下面这样一颗红黑树：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_insert_1.png" alt></p><p>当我们插入值为66的节点的时候，示意图如下：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_insert_2.png" alt></p><p>很明显，这个时候结构依然遵循着上述5大特性，无需启动自动平衡机制调整节点平衡状态。</p><p>如果再向里面插入值为51的节点呢，这个时候红黑树变成了这样。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_insert_3.png" alt></p><p>这样的结构实际上是不满足性质4的，红色两个子节点必须是黑色的，而这里49这个红色节点现在有个51的红色节点与其相连。</p><p>这个时候我们需要调整这个树的结构来保证红黑树的平衡。</p><p>首先尝试将49这个节点设置为黑色，如下示意图。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_add_1.webp" alt></p><p>这个时候我们发现黑高是不对的，其中 60-56-45-49-51-null 这条路径有 4 个黑节点，其他路径的黑色节点是 3 个。</p><p>接着调整红黑树，我们再次尝试把45这个节点设置为红色的，如下图所示：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_add_2.webp" alt></p><p>这个时候我们发现问题又来了，56-45-43 都是红色节点的，出现了红色节点相连的问题。</p><p>于是我们需要再把 56 和 43 设置为黑色的，如下图所示。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_add_3.webp" alt></p><p>于是我们把 68 这个红色节点设置为黑色的。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_insert_5.png" alt></p><p>对于这种红黑树插入节点的情况下，我们可以只需要通过变色就可以保持树的平衡了。但是并不是每次都是这么幸运的，当变色行不通的时候，我们需要考虑另一个手段就是旋转了。</p><p>例如下面这种情况，同样还是拿这颗红黑树举例。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_insert_2.png" alt></p><p>现在这颗红黑树，我们现在插入节点65。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_1.png" alt></p><p>我们尝试把 66 这个节点设置为黑色，如下图所示。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/rec_black_tree_new_2.png" alt></p><p>这样操作之后黑高又出现不一致的情况了，60-68-64-null 有 3 个黑色节点，而60-68-64-66-null 这条路径有 4 个黑色节点，这样的结构是不平衡的。</p><p>或者我们把 68 设置为黑色，把 64 设置为红色，如下图所示：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_3.png" alt></p><p>但是，同样的问题，上面这颗红黑树的黑色高度还是不一致，60-68-64-null 和 60-68-64-66-null 这两条路径黑色高度还是不一致。</p><p>这种情况如果只通过变色的情况是不能保持红黑树的平衡的。</p><h3 id="红黑树的旋转"><a href="#红黑树的旋转" class="headerlink" title="红黑树的旋转"></a>红黑树的旋转</h3><p>接下来我们讲讲红黑树的旋转，旋转分为左旋和右旋。</p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p>文字描述：逆时针旋转两个节点，让一个节点被其右子节点取代，而该节点成为右子节点的左子节点。</p><p>文字描述太抽象，接下来看下图片展示。</p><p>首先断开节点PL与右子节点G的关系，同时将其右子节点的引用指向节点C2；然后断开节点G与左子节点C2的关系，同时将G的左子节点的应用指向节点PL。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_rotate_left.png" alt></p><p>接下来再放下 gif 图，希望能帮助大家更好地理解左旋，图片来自网络。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_rotate_left.gif" alt></p><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p>文字描述：顺时针旋转两个节点，让一个节点被其左子节点取代，而该节点成为左子节点的右子节点。</p><p>右旋的图片展示：</p><p>首先断开节点G与左子节点PL的关系，同时将其左子节点的引用指向节点C2；然后断开节点PL与右子节点C2的关系，同时将PL的右子节点的应用指向节点G。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_rotate_right.png" alt></p><p>右旋的gif展示（图片来自网络）:</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_rotate_right.gif" alt></p><p>介绍完了左旋和右旋基本操作，我们来详细介绍下红黑树的几种旋转场景。</p><h4 id="左左节点旋转（插入节点的父节点是左节点，插入节点也是左节点）"><a href="#左左节点旋转（插入节点的父节点是左节点，插入节点也是左节点）" class="headerlink" title="左左节点旋转（插入节点的父节点是左节点，插入节点也是左节点）"></a>左左节点旋转（插入节点的父节点是左节点，插入节点也是左节点）</h4><p>如下图所示的红黑树，我们插入节点是65。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_rotate_1.png" alt></p><p>操作步骤如下可以围绕祖父节点 69 右旋，再结合变色，步骤如下所示：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_rotate_2.png" alt></p><h4 id="左右节点旋转（插入节点的父节点是左节点，插入节点是右节点）"><a href="#左右节点旋转（插入节点的父节点是左节点，插入节点是右节点）" class="headerlink" title="左右节点旋转（插入节点的父节点是左节点，插入节点是右节点）"></a>左右节点旋转（插入节点的父节点是左节点，插入节点是右节点）</h4><p>还是上面这颗红黑树，我们再插入节点 67。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_rotate_1.png" alt></p><p>这种情况我们可以这样操作，先围绕父节点 66 左旋，然后再围绕祖父节点 69 右旋，最后再将 67 设置为黑色，把 69 设置为红色，如下图所示。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_rotate_3.png" alt></p><h4 id="右左节点旋转（插入节点的父节点是右节点，插入节点左节点）"><a href="#右左节点旋转（插入节点的父节点是右节点，插入节点左节点）" class="headerlink" title="右左节点旋转（插入节点的父节点是右节点，插入节点左节点）"></a>右左节点旋转（插入节点的父节点是右节点，插入节点左节点）</h4><p>如下图这种情况，我们要插入节点68。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_rotate_4.png" alt></p><p>这种情况，我们可以先围绕父节点 69 右旋，接着再围绕祖父节点 66 左旋，最后把 68 节点设置为黑色，把 66 设置为红色，我们的具体操作步骤如下所示。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_rotate_5.png" alt></p><h4 id="右右节点旋转（插入节点的父节点是右节点，插入节点也是右节点）"><a href="#右右节点旋转（插入节点的父节点是右节点，插入节点也是右节点）" class="headerlink" title="右右节点旋转（插入节点的父节点是右节点，插入节点也是右节点）"></a>右右节点旋转（插入节点的父节点是右节点，插入节点也是右节点）</h4><p>还是来上面的图来举例，我们在这颗红黑树上插入节点 70 。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_rotate_4.png" alt></p><p>我们可以这样操作围绕祖父节点 66 左旋，再把旋转后的根节点 69 设置为黑色，把 66 这个节点设置为红色。具体可以参看下图：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_rotate_6.png" alt></p><h3 id="红黑树在-Java-中的实现"><a href="#红黑树在-Java-中的实现" class="headerlink" title="红黑树在 Java 中的实现"></a>红黑树在 Java 中的实现</h3><p>Java 中的红黑树实现类是 TreeMap ，接下来我们尝试从源码角度来逐行解释 TreeMap 这一套机制是如何运作的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// TreeMap中使用Entry来描述每个节点</span><br><span class="line"> static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; left;</span><br><span class="line">        Entry&lt;K,V&gt; right;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        boolean color = BLACK;</span><br><span class="line">        ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>TreeMap 的put方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">       //先以t保存链表的root节点</span><br><span class="line">       Entry&lt;K,V&gt; t = root;</span><br><span class="line">       //如果t=null,表明是一个空链表，即该TreeMap里没有任何Entry作为root</span><br><span class="line">       if (t == null) &#123;</span><br><span class="line">           compare(key, key); // type (and possibly null) check</span><br><span class="line">           //将新的key-value创建一个Entry，并将该Entry作为root</span><br><span class="line">           root = new Entry&lt;&gt;(key, value, null);</span><br><span class="line">           size = 1;</span><br><span class="line">           //记录修改次数加1</span><br><span class="line">           modCount++;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       int cmp;</span><br><span class="line">       Entry&lt;K,V&gt; parent;</span><br><span class="line">       // split comparator and comparable paths</span><br><span class="line">       Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">       //如果比较器cpr不为null，即表明采用定制排序</span><br><span class="line">       if (cpr != null) &#123;</span><br><span class="line">           do &#123;</span><br><span class="line">               //使用parent上次循环后的t所引用的Entry</span><br><span class="line">               parent = t;</span><br><span class="line">                //将新插入的key和t的key进行比较</span><br><span class="line">               cmp = cpr.compare(key, t.key);</span><br><span class="line">               //如果新插入的key小于t的key，t等于t的左边节点</span><br><span class="line">               if (cmp &lt; 0)</span><br><span class="line">                   t = t.left;</span><br><span class="line">               //如果新插入的key大于t的key，t等于t的右边节点    </span><br><span class="line">               else if (cmp &gt; 0)</span><br><span class="line">                   t = t.right;</span><br><span class="line">               else</span><br><span class="line">               //如果两个key相等，新value覆盖原有的value，并返回原有的value</span><br><span class="line">                   return t.setValue(value);</span><br><span class="line">           &#125; while (t != null);</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">           if (key == null)</span><br><span class="line">               throw new NullPointerException();</span><br><span class="line">           @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">               Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span><br><span class="line">           do &#123;</span><br><span class="line">               parent = t;</span><br><span class="line">               cmp = k.compareTo(t.key);</span><br><span class="line">               if (cmp &lt; 0)</span><br><span class="line">                   t = t.left;</span><br><span class="line">               else if (cmp &gt; 0)</span><br><span class="line">                   t = t.right;</span><br><span class="line">               else</span><br><span class="line">                   return t.setValue(value);</span><br><span class="line">           &#125; while (t != null);</span><br><span class="line">       &#125;</span><br><span class="line">       //将新插入的节点作为parent节点的子节点</span><br><span class="line">       Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</span><br><span class="line">       //如果新插入key小于parent的key,则e作为parent的左子节点</span><br><span class="line">       if (cmp &lt; 0)</span><br><span class="line">           parent.left = e;</span><br><span class="line">       //如果新插入key小于parent的key，则e作为parent的右子节点</span><br><span class="line">       else</span><br><span class="line">           parent.right = e;</span><br><span class="line">       //修复红黑树</span><br><span class="line">       fixAfterInsertion(e);</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//插入节点后修复红黑树</span><br><span class="line">private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    //直到x节点的父节点不是根，且x的父节点是红色</span><br><span class="line">    while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        //如果x的父节点是其父节点的左子节点</span><br><span class="line">        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            //获取x的父节点的兄弟节点</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            //如果x的父节点的兄弟节点是红色</span><br><span class="line">            if (colorOf(y) == RED) &#123;     </span><br><span class="line">                //将x的父节点设置为黑色</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                //将x的父节点的兄弟节点设置为黑色</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                //将x的父节点的父节点设为红色</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line">            //如果x的父节点的兄弟节点是黑色</span><br><span class="line">            else &#123;   </span><br><span class="line">                //TODO 对应情况第二种，左右节点旋转</span><br><span class="line">                //如果x是其父节点的右子节点</span><br><span class="line">                if (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    //将x的父节点设为x</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    //右旋转</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                //把x的父节点设置为黑色</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                //把x的父节点父节点设为红色</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果x的父节点是其父节点的右子节点</span><br><span class="line">        else &#123;</span><br><span class="line">            //获取x的父节点的兄弟节点</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            //只着色的情况对应的是最开始例子，没有旋转操作，但是要对应多次变换</span><br><span class="line">            //如果x的父节点的兄弟节点是红色  </span><br><span class="line">            if (colorOf(y) == RED) &#123;</span><br><span class="line">                //将x的父节点设置为黑色</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                //将x的父节点的兄弟节点设为黑色</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                //将X的父节点的父节点（G）设置红色</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                //将x设为x的父节点的节点</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line">            //如果x的父节点的兄弟节点是黑色</span><br><span class="line">            else &#123;</span><br><span class="line">                //如果x是其父节点的左子节点</span><br><span class="line">                if (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    //将x的父节点设为x</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    //右旋转</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                //将x的父节点设为黑色</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                //把x的父节点的父节点设为红色</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将根节点强制设置为黑色</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeMap的插入节点和普通的排序二叉树没啥区别，唯一不同的是，在TreeMap 插入节点后会调用方法fixAfterInsertion(e)来重新调整红黑树的结构来让红黑树保持平衡。</p><p>我们重点关注下红黑树的fixAfterInsertion(e)方法，接下来我们来分别介绍两种场景来演示fixAfterInsertion(e)方法的执行流程。</p><h3 id="第一种场景：只需变色即可平衡"><a href="#第一种场景：只需变色即可平衡" class="headerlink" title="第一种场景：只需变色即可平衡"></a>第一种场景：只需变色即可平衡</h3><p>同样是拿这颗红黑树举例，现在我们插入节点 51。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_insert_2.png" alt></p><p>当我们需要插入节点51的时候，这个时候TreeMap 的 put 方法执行后会得到下面这张图。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_insert_3.png" alt></p><p>接着调用fixAfterInsertion(e)方法，如下代码流程所示。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_code_1.png" alt></p><p>当第一次进入循环后，执行后会得到下面的红黑树结构。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_4.png" alt></p><p>在把 x 重新赋值后，重新进入 while 循环，此时的 x 节点为 45 。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_5.png" alt></p><p>执行上述流程后，得到下面所示的红黑树结构。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_6.png" alt></p><p>这个时候x被重新赋值为60，因为60是根节点，所以会退出 while 循环。在退出循序后，会再次把根节点设置为黑色，得到最终的结构如下图所示。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_7.png" alt></p><p>最后经过两次执行while循环后，我们的红黑树会调整成现在这样的结构，这样的红黑树结构是平衡的，所以路径的黑高一致，并且没有红色节点相连的情况。</p><h3 id="第二种场景-旋转搭配变色来保持平衡"><a href="#第二种场景-旋转搭配变色来保持平衡" class="headerlink" title="第二种场景 旋转搭配变色来保持平衡"></a>第二种场景 旋转搭配变色来保持平衡</h3><p>接下来我们再来演示第二种场景，需要结合变色和旋转一起来保持平衡。</p><p>给定下面这样一颗红黑树：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_8.png" alt></p><p>现在我们插入节点66，得到如下树结构。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_9.png" alt></p><p>同样地，我们进入fixAfterInsertion(e)方法。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_10.png" alt></p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_11.png" alt></p><p>最终我们得到的红黑树结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_new_12.png" alt></p><p>调整成这样的结构我们的红黑树又再次保持平衡了。</p><p>演示 TreeMap 的流程就拿这两种场景举例了，其他的就不一一举例了。</p><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p>因为之前的分享只整理了红黑树的插入部分，本来想着红黑树的删除就不整理了，有人跟我反馈说红黑树的删除相对更复杂，于是索性还是把红黑树的删除再整理下。</p><p>删除相对插入来说，的确是要复杂一点，但是复杂的地方是因为在删除节点的这个操作情况有很多种，但是插入不一样，插入节点的时候实际上这个节点的位置是确定的，在节点插入成功后只需要调整红黑树的平衡就可以了。</p><p>但是删除不一样的是，删除节点的时候我们不能简单地把这个节点设置为null，因为如果这个节点有子节点的情况下，不能简单地把当前删除的节点设置为null，这个被删除的节点的位置需要有新的节点来填补。这样一来，需要分多种情况来处理了。</p><h4 id="删除节点是根节点"><a href="#删除节点是根节点" class="headerlink" title="删除节点是根节点"></a>删除节点是根节点</h4><p>直接删除根节点即可。</p><h4 id="删掉节点的左子节点和右子节点都是为空"><a href="#删掉节点的左子节点和右子节点都是为空" class="headerlink" title="删掉节点的左子节点和右子节点都是为空"></a>删掉节点的左子节点和右子节点都是为空</h4><p>直接删除当前节点即可。</p><h4 id="删除节点有一个子节点不为空"><a href="#删除节点有一个子节点不为空" class="headerlink" title="删除节点有一个子节点不为空"></a>删除节点有一个子节点不为空</h4><p>这个时候需要使用子节点来代替当前需要删除的节点，然后再把子节点删除即可。</p><p>给定下面这棵树，当我们需要删除节点69的时候。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_del_1.png" alt></p><p>首先用子节点代替当前待删除节点，然后再把子节点删除。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_del_2.png" alt></p><p>最终的红黑树结构如下面所示，这个结构的红黑树我们是不需要通过变色+旋转来保持红黑树的平衡了，因为将子节点删除后树已经是平衡的了。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_del_3.png" alt></p><p>还有一种场景是当我们待删除节点是黑色的，黑色的节点被删除后，树的黑高就会出现不一致的情况，这个时候就需要重新调整结构。</p><p>还是拿上面这颗删除节点后的红黑树举例，我们现在需要删除节点67。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_del_4.png" alt></p><p>因为67 这个节点的两个子节点都是null，所以直接删除,得到如下图所示结构：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_del_5.png" alt></p><p>这个时候我们树的黑高是不一致的，左边黑高是3，右边是2，所以我们需要把64节点设置为红色来保持平衡。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_del_6.png" alt></p><h4 id="删除节点两个子节点都不为空"><a href="#删除节点两个子节点都不为空" class="headerlink" title="删除节点两个子节点都不为空"></a>删除节点两个子节点都不为空</h4><p>删除节点两个子节点都不为空的情况下，跟上面有一个节点不为空的情况下也是有点类似，同样是需要找能替代当前节点的节点，找到后，把能替代删除节点值复制过来，然后再把替代节点删除掉。</p><ul><li>先找到替代节点，也就是前驱节点或者后继节点</li><li>然后把前驱节点或者后继节点复制到当前待删除节点的位置，然后在删除前驱节点或者后继节点。</li></ul><p>那么什么叫做前驱，什么叫做后继呢？<br>前驱是左子树中最大的节点，后继则是右子树中最小的节点。</p><p>前驱或者后继都是最接近当前节点的节点，当我们需要删除当前节点的时候，也就是找到能替代当前节点的节点，能够替代当前节点肯定是最接近当前节点。</p><p>在当前删除节点两个子节点不为空的场景下，我们需要再进行细分，主要分为以下三种情况。</p><h5 id="第一种，前驱节点为黑色节点，同时有一个非空节点"><a href="#第一种，前驱节点为黑色节点，同时有一个非空节点" class="headerlink" title="第一种，前驱节点为黑色节点，同时有一个非空节点"></a>第一种，前驱节点为黑色节点，同时有一个非空节点</h5><p>如下面这样一棵树，我们需要删除节点64：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_delete_1.jpg" alt></p><p>首先找到前驱节点，把前驱节点复制到当前节点：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_delete_2.jpg" alt></p><p>接着删除前驱节点。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_delete_3.jpg" alt></p><p>这个时候63和60这个节点都是红色的，我们尝试把60这个节点设置为红色即可使整个红黑树达到平衡。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_delete_4.jpg" alt></p><h5 id="第二种，前驱节点为黑色节点，同时子节点都为空"><a href="#第二种，前驱节点为黑色节点，同时子节点都为空" class="headerlink" title="第二种，前驱节点为黑色节点，同时子节点都为空"></a>第二种，前驱节点为黑色节点，同时子节点都为空</h5><p>前驱节点是黑色的，子节点都为空，这个时候操作步骤与上面基本类似。</p><p>如下操作步骤：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_delete_5.png" alt></p><p>因为要删除节点64，接着找到前驱节点63，把63节点复制到当前位置，然后将前驱节点63删除掉，变色后出现黑高不一致的情况下，最后把63节点设置为黑色，把65节点设置为红色，这样就能保证红黑树的平衡。</p><h5 id="第三种，前驱节点为红色节点，同时子节点都为空"><a href="#第三种，前驱节点为红色节点，同时子节点都为空" class="headerlink" title="第三种，前驱节点为红色节点，同时子节点都为空"></a>第三种，前驱节点为红色节点，同时子节点都为空</h5><p>给定下面这颗红黑树，我们需要删除节点64的时候。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_delete_6.jpg" alt></p><p>同样地，我们找到64的前驱节点63，接着把63赋值到64这个位置。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_delete_7.jpg" alt></p><p>然后删除前驱节点。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/red_black_tree_delete_8.jpg" alt></p><p>删除节点后不需要变色也不需要旋转即可保持树的平衡。</p><p>终于把红黑树的基本原理部分写完了，用了很多示意图，这篇文章是在之前分享的 ppt 上再整理出来，我觉得自己应该算是把基本操作讲明白了，整理这篇文章前前后后用了近一周左右，因为平时上班，基本上只有周末有时间才有时间整理，如有问题请留言讨论。</p><p>如果您觉得写得还可以，请您帮忙点个好看，您的点赞真的是对我最大的支持，也是我能继续写下去的动力，感谢。</p><p><a href="https://github.com/JasonGaoH/KnowledgeSummary/blob/master/Docs/Java/%E6%88%91%E7%94%BB%E4%BA%86%E8%BF%91%E7%99%BE%E5%BC%A0%E5%9B%BE%E6%9D%A5%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91.md" target="_blank" rel="noopener">原文链接</a></p><p>文章中很多参考了下面文章的一些示意图，非常感谢以下文章。</p><p><a href="https://hackernoon.com/what-does-the-time-complexity-o-log-n-actually-mean-45f94bb5bfbf" target="_blank" rel="noopener">What does the time complexity O(log n) actually mean?</a></p><p><a href="https://blog.csdn.net/chenssy/article/details/26668941" target="_blank" rel="noopener">Java提高篇–TreeMap</a></p><p><a href="https://www.cnblogs.com/LiaHon/p/11203229.html" target="_blank" rel="noopener">关于红黑树(R-B tree)原理，看这篇如何</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章已同步发表于微信公众号JasonGaoH，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNTE2OTAzMQ==&amp;amp;mid=2247483855&amp;amp;idx=1&amp;amp;sn=673e581b766d6ec80ec6151e5d732a32&amp;amp;chksm=fa237927cd54f031d5df25b8783551d889200ddab408d1cc5c12533b9d5ab85f99ba78d07b06&amp;amp;token=1938879438&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我画了近百张图来理解红黑树&lt;/a&gt;,文章略有修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前在公司组内分享了红黑树的工作原理，今天把它整理下发出来，希望能对大家有所帮助，对自己也算是一个知识点的总结。&lt;/p&gt;
&lt;p&gt;这篇文章算是我写博客写公众号以来画图最多的一篇文章了，没有之一，我希望尽可能多地用图片来形象地描述红黑树的各种操作的前后变换原理，帮助大家来理解红黑树的工作原理，下面，多图预警开始了。&lt;br&gt;</summary>
    
    
    
    <category term="源码分析" scheme="JasonGaoH.github.io/categories/源码分析/"/>
    
    
    <category term="红黑树，TreeMap" scheme="JasonGaoH.github.io/tags/红黑树，TreeMap/"/>
    
  </entry>
  
  <entry>
    <title>仿京东、淘宝首页，通过两层嵌套的RecyclerView实现tab的吸顶效果</title>
    <link href="JasonGaoH.github.io/2020/05/21/The-tab&#39;s-sticky-effect./"/>
    <id>JasonGaoH.github.io/2020/05/21/The-tab&#39;s-sticky-effect./</id>
    <published>2020-05-21T01:08:26.000Z</published>
    <updated>2023-08-08T11:19:27.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章已同步发表于微信公众号JasonGaoH，<a href="https://mp.weixin.qq.com/s?__biz=MzUyNTE2OTAzMQ==&amp;mid=2247483770&amp;idx=1&amp;sn=38b95c3cff51e216248c0eb860155437&amp;chksm=fa237992cd54f084802be4b0be2b52e4f5052019d51562f65245ca8b0faf3e0d61d296fc0e7d&amp;token=1938879438&amp;lang=zh_CN#rd" target="_blank" rel="noopener">仿京东、淘宝首页，通过两层嵌套的RecyclerView实现tab的吸顶效果</a></p></blockquote><h3 id="为什么会有这篇文章"><a href="#为什么会有这篇文章" class="headerlink" title="为什么会有这篇文章"></a>为什么会有这篇文章</h3><p>之前写过一篇文章<a href="https://juejin.im/post/5d233cc86fb9a07ec42b7f57" target="_blank" rel="noopener">使用CoordinatorLayout过程中遇到的两个问题以及浅析CoordinatorLayout工作机制</a>，这篇文章上主要讲了通过CoordinatorLayout实现tab吸顶的效果时遇到的问题，效果跟京东、淘宝首页类似，只不过实现方法不同而已，但是使用CoordinatorLayout来实现是会有不少细节问题是很难处理好的，下面会详细介绍。</p><a id="more"></a><p>首先我们可以简单看下京东首页的效果gif，来看看我们到底是要实现什么样的效果：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/jingdong.gif" alt="image"></p><p>京东首页的tab筛选区将feed分为两个部分，上面是各种不同item，tab的下半部分可以左右横滑，并且下拉可以加重更多，只要网络有数据的情况下理论上是可以无限下拉的。</p><p>其实用CoordinatorLayout来实现tab吸顶，如果能将一些细节问题处理好的话，其实大致可以实现类似京东首页的这个效果，具体细节问题可以参考文章开头说的之前的文章，文章里讲了下使用CoordinatorLayout来实现类似效果遇到的动画抖动问题以及页面回弹问题以及对应的解决方法。</p><p>那么为什么会不采用CoordinatorLayout来实现，转而采用嵌套RecyclerView的方式呢？</p><p>首先我们来看下CoordinatorLayout实现的大致布局：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/CoordinatorLayout.png" alt="image"></p><p>一个问题是从AppBarLayout滑动效果是不能传递到下面的ViewPager里去的，我尝试了各种方式都没能解决掉这个问题，可以简单看下Demo效果图：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/coordinatorlayout_fix.gif" alt="image"></p><p>从gif图大致可以看到AppBarLayout滑上去之后惯性消失了，tab下面的区域是不能接着滚动的。</p><blockquote><p>这个惯性消失的问题，我在网上找到了一个一篇解决惯性消失的文章如下<a href="https://blog.kyleduo.com/2017/07/21/alipay-home-3-alipay-home/" target="_blank" rel="noopener">支付宝首页交互三部曲3实现支付宝首页交互</a>,实现方式大致是自己把CoordinatorLayout这套机制再实现了一遍，因为是自己实现的，里面的一些机制是比较方便改动的，它处理惯性这个问题的逻辑大致是将AppBarLayout中未消费的y轴偏移量拿出来再交由RecyclerView去滑动，代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mHeaderView.setOnHeaderFlingUnConsumedListener(<span class="keyword">new</span> APHeaderView.OnHeaderFlingUnConsumedListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onFlingUnConsumed</span><span class="params">(APHeaderView header, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> unconsumed)</span> </span>&#123;</span><br><span class="line">        APHeaderView.Behavior behavior = mHeaderView.getBehavior();</span><br><span class="line">        <span class="keyword">int</span> dy = -unconsumed;</span><br><span class="line">        <span class="keyword">if</span> (behavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRecyclerView.scrollBy(<span class="number">0</span>, dy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>这里由于篇幅原因，就不展开详细介绍了，感兴趣地同学可以点开上面的链接去研究研究，文章中也贴出了GitHub地址。</p></blockquote><p>我们重新回到我们一开始的问题，为什么想替换掉CoordinatorLayout，另外一个问题是CoordinatorLayout这种实现相对比较简单，但是会导致页面的嵌套层级很深，我们从上面贴出来的布局来看，view嵌套的层级特别深，而且如果我们要实现类似京东或者淘宝首页这样的效果，在TabLayout上面的区域，也就是下图箭头标注的地方必须要采用RecyclerView的来实现，因为tab上半部分的内容和个数都是不确定的，使用RecyclerView才比较方便，但是这样页面的层级就更深了，加载速度也变得更慢了。</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/CoordinatorLayout_fix.png" alt="image"></p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>要抛弃CoordinatorLayout，那么如何实现呢？</p><p>我们用Android Studio中的Layout Inspector工具看了下京东首页的布局，发现的确是采用两层RecyclerView嵌套来实现的，展示的布局大致如下所示：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/jingdong_layout.png" alt="image"></p><p>那么接下来是怎么去实现这个效果了。其实一开始我以为要采用嵌套滚动这套机制来实现，后来发现不采用嵌套滚动机制也是可以实现的。</p><p>现在我们可以大致构造这样一个布局：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/Images/master/nested_recycler_view.png" alt="image"></p><p>我们把ViewPager以及TabLayout这一块作为外部RecyclerView的一个item，ViewPager可能会有个多个内部RecyclerView，只要我们能让外部RecyclerView和内部RecyclerView的滑动事件正确分发基本就可以解决这个问题了。</p><p>如果只是构造出这个布局出来，我们发现内部的RecyclerView都不会显示出来，因为滑动完全由外部RecyclerView接管了。</p><p>那么重点来了，这种情况如何处理？</p><p>其实RecyclerView的LayoutManager中有这两个方法用于判断RecyclerView在水平方向上和竖直方向上是否可以滚动的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean canScrollHorizontally() &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean canScrollVertically() &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后LayoutManager有各种不同的实现LinearLayoutManager，StaggeredGridLayoutManager等</p><p>这个LayoutManager中的canScrollVertically和canScrollHorizontally在RecyclerView的onInterceptTouchEvent中是会拿来作判断，判断当前RecyclerView是否需要处理滑动事件的。</p><blockquote><p>还有一点需要注意：我们处理内外两层RecyclerView的滑动冲突问题，主要是想解决下面两种场景：一、手指上滑时，当外部RecyclerView滑动底部的时候，内部的RecyclerView能继续去响应用户的滑动，因为内部的RecyclerView理论上是可以无限滚动的；二、手指下滑时，当内部的RecyclerView滑动到顶部的时候，外部的RecyclerView能够继续响应用户的下滑事件。</p></blockquote><p>其实上面已经说出了如何处理嵌套RecyclerView的最重要的点，其他的部分相当于都是一些细节的处理了。</p><p>在外部RecyclerView(下面成ParentRecyclerView)中的重写LayoutManager的canScrollVertically方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun initLayoutManager() &#123;</span><br><span class="line">    val linearLayoutManager = object :LinearLayoutManager(context) &#123;</span><br><span class="line"></span><br><span class="line">        override fun canScrollVertically():Boolean &#123;</span><br><span class="line">            //找到当前的childRecyclerView</span><br><span class="line">            val childRecyclerView = findNestedScrollingChildRecyclerView()</span><br><span class="line">            //只有当前childRecyclerView滑动到顶部才认为ParentRecyclerView是可以竖直方向是可以滚动的</span><br><span class="line">            return childRecyclerView == null || childRecyclerView.isScrollTop()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    linearLayoutManager.orientation = LinearLayoutManager.VERTICAL</span><br><span class="line">    layoutManager = linearLayoutManager</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内部RecyclerView(以下称ChildRecyclerView)中定义了isScrollTop()，用于判断ChildRecyclerView是否滚动到顶部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun isScrollTop(): Boolean &#123;</span><br><span class="line">    //RecyclerView.canScrollVertically(-1)的值表示是否能向下滚动，false表示已经滚动到顶部</span><br><span class="line">    return !canScrollVertically(-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外，在ParentRecyclerView的onTouchEvent方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">override fun onTouchEvent(e: MotionEvent): Boolean &#123;</span><br><span class="line">        if(lastY == 0f) &#123;</span><br><span class="line">            lastY = e.y</span><br><span class="line">        &#125;</span><br><span class="line">        if(isScrollEnd()) &#123;</span><br><span class="line">            //如果父RecyclerView已经滑动到底部，需要让子RecyclerView滑动剩余的距离</span><br><span class="line">            val childRecyclerView = findNestedScrollingChildRecyclerView()</span><br><span class="line">            childRecyclerView?.run &#123;</span><br><span class="line">                val deltaY = (lastY - e.y).toInt()</span><br><span class="line">                if(deltaY != 0) &#123;</span><br><span class="line">                    scrollBy(0,deltaY)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastY = e.y</span><br><span class="line">        return try &#123;</span><br><span class="line">            super.onTouchEvent(e)</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">            false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>关于滑动事件主要代码就是上面这些，具体可以可以看看项目代码<a href="https://github.com/JasonGaoH/NestedRecyclerView" target="_blank" rel="noopener">NestedRecyclerView</a>。</p><p>还有关于RecyclerView的fling部分，在RecyclerView的onScrollStateChanged回调中监听y轴的总的偏移量totalDy，然后在RecyclerView不滚动的时候交由内部或者外部RecyclerView去fling，这里就不赘述了，具体可以看项目的代码。</p><p>最后贴上项目的运行gif图展示：</p><p><img src="https://raw.githubusercontent.com/JasonGaoH/NestedRecyclerView/master/gif/nested_recyclerview_1.gif" alt="image"></p><p><img src="https://raw.githubusercontent.com/JasonGaoH/NestedRecyclerView/master/gif/nested_recyclerview_2.gif" alt="image"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>写作不易，欢迎大家点赞，如果有问题，欢迎提出一起讨论，您的点赞是我写作的最大动力，感谢！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章已同步发表于微信公众号JasonGaoH，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNTE2OTAzMQ==&amp;amp;mid=2247483770&amp;amp;idx=1&amp;amp;sn=38b95c3cff51e216248c0eb860155437&amp;amp;chksm=fa237992cd54f084802be4b0be2b52e4f5052019d51562f65245ca8b0faf3e0d61d296fc0e7d&amp;amp;token=1938879438&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仿京东、淘宝首页，通过两层嵌套的RecyclerView实现tab的吸顶效果&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么会有这篇文章&quot;&gt;&lt;a href=&quot;#为什么会有这篇文章&quot; class=&quot;headerlink&quot; title=&quot;为什么会有这篇文章&quot;&gt;&lt;/a&gt;为什么会有这篇文章&lt;/h3&gt;&lt;p&gt;之前写过一篇文章&lt;a href=&quot;https://juejin.im/post/5d233cc86fb9a07ec42b7f57&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用CoordinatorLayout过程中遇到的两个问题以及浅析CoordinatorLayout工作机制&lt;/a&gt;，这篇文章上主要讲了通过CoordinatorLayout实现tab吸顶的效果时遇到的问题，效果跟京东、淘宝首页类似，只不过实现方法不同而已，但是使用CoordinatorLayout来实现是会有不少细节问题是很难处理好的，下面会详细介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="RecyclerView" scheme="JasonGaoH.github.io/tags/RecyclerView/"/>
    
  </entry>
  
</feed>
